[
["index.html", "FAQS Laboratori de Fonaments de Programació Introducció", " FAQS Laboratori de Fonaments de Programació Jordi Blasco Planesas 2020-02-19 Introducció El present recurs és un recopilatori de qüestions plantejades al Laboratori de Fonaments de Programació durant els últims semestres. Les FAQS poden donar resposta a dubtes i errors habituals en el moment d’iniciar-nos en el món de la programació. També es poden utilitzar com a material complementari a la teoria explicada a la xWiki de Fonaments de Programació. La lectura de les FAQS no cal realitzar-la seqüencialment: cada apartat respon a una consulta o conjunt de consultes, sense relació necessària entre ells. El fil conductor són les PAC : les diferents respostes donades al Laboratori de Fonaments de Programació s’han agrupat en PAC segons el moment en que es van produïr. Això no significa que una resposta d’una PAC anterior o posterior a la que estiguem tractant, no ens pugui ser d’utilitat. Donada aquesta independència de contingut és recomanable utilitzar el cercador del portal: per exemple, si volem cercar consultes on s’hagi tractat strlen, simplement posem aquesta comanda al cercador i obtindrem la relació d’entrades que la contenen. És possible descarregar una versió en PDF/EPUB de totes les FAQS, des del botó de descàrrega de la part superior. La documentació utilitza les següents icones per referenciar els blocs: Indica que el codi mostrat està en llenguatge algorísmic. Indica que el codi mostrat està en llenguatge C. Mostra l’execució d’un programa en llenguatge C. "],
["pac01.html", " 1 PAC01 1.1 Llenguatge algorísmic 1.2 Llenguatge algorísmic vs llenguatge C 1.3 Equivalències llenguatge algorísmic vs llenguatge C 1.4 Impressió de valors incorrecta 1.5 Com definir un enumeratiu 1.6 Com utilitzar un enumeratiu 1.7 Especificador d’un enumeratiu 1.8 Lectura de caràcters en C 1.9 Lectura de float en C", " 1 PAC01 1.1 Llenguatge algorísmic El llenguatge algorísmic l’hem d’entendre com una aproximació al món real, el qual utilitza unes normes definides per nosaltres mateixos. En aquest punt encara no parlem de programes escrits en C, en Java, en Python o en PHP, per dir alguns llenguatges de programació. Per exemple, en el llenguatge algorísmic que utilitzem a l’assignatura definim un bloc de variables de la següent forma: var edat: integer; pes: real; end var Que es tracti d’un llenguatge més proper al món real no significa que no s’hagin de complir unes determinades regles. Com es pot veure en aquest exemple, una d’aquestes regles és que quan definim variables ho precedim amb var i ho finalitzem amb end var. Hem decidit utilitzar aquesta forma de llenguatge algorísmic, tot i que també ho podríem haver plantejat de la següent forma : variable enter edat decimal pes fvariable Remarcar que aquest segon exemple és incorrecte, no segueix la nomenclatura del llenguatge algorísmic definit a l’assignatura. El correcte és el primer exemple. El llenguatge algorísmic és com fer una aproximació formal a la realitat, no és un llenguatge de programació en sí com és C, Java o similars. Per tant no és un llenguatge que es pugui compilar i executar amb l’IDE utilitzat a l’assignatura, el qual està preparat únicament per interpretar i executar codi programat en llenguatge C. Ara bé la gran pregunta: i per què és necessari primer dissenyar l’algorisme, si puc directament programar-ho en C? Un algorisme ens permet dissenyar un programa sense tenir presents les particularitats de cada llenguatge de programació. Aquesta aproximació formal a la realitat dels algorismes ens faciliten poder fer posteriorment una traducció ràpida a qualsevol llenguatge de programació simplement coneixent les equivalències corresponents. Per exemple, el primer cas si el programem en C equival a: int edat; float pes; El codi en C no el podem canviar, ja que si en comptes de posar int utilitzem enter, el compilador de C no comprèn el mot i ens donarà un error de codi. Si mai hem programat és normal que aquest plantejament sobti al principi, però és important que poc a poc es vagi veient les diferències entre llenguatge algorísmic i llenguatge C. 1.2 Llenguatge algorísmic vs llenguatge C En general: Llenguatge algorísmic: proper al llenguatge natural, es tracta d’una convenció que adoptem nosaltres mateixos per definir el un programa formalment. Els algorismes tenen una sèrie de normes i sentències que nosaltres definim (Nomenclàtor), però que no són de cap forma interpretables per un ordinador. Per tant un algorisme no pot ser compilat ni executat. Llenguatge C: es tracta d’un llenguatge de programació que sí comprèn un ordinador. Això significa que únicament podem utilitzar les seves comandes i les seves normes per tal que el codi pugui ser compilat i executat sense problemes. El llenguatge algorísmic és un pseudocodi que ens ajuda a definir com funciona un programa. No està lligat a cap llenguatge de programació, amb el que les accions que realitzarà, la forma de definir variables, etc. és genèrica. Funcions com writeString(), readInteger() o writeChar() formen part del llenguatge algorísmic: indiquen una acció genèrica a realitzar, com és escriure una cadena de caracters, llegir un enter o escriure un caràcter. Quan es vulgui codificar aquest algorisme en un llenguatge de programació concret com és C, només caldrà saber les comandes pròpies de C que ens permeten implementar l’algorisme. La programació en C funciona exclusivament amb la sintaxi definida per aquest llenguatge de programació. Instruccions com scanf() i printf() són pròpies de C. A mode d’exemple: Algorisme: volem introduïr la lectura de la llum de casa nostra; una possible implementació és: algorithm lecturaLlum var lecturaMensual: integer; end var writeString(&quot;Introdueix la lectura mensual de la llum (kWh): &quot;); lecturaMensual := readInteger(); end algorithm Llenguatge C: en aquest llenguatge no existeixen les funcions algorísmiques writeString() ni readInteger(), però en canvi sí que tenim vàries funcions pròpies de C que ens permeten llegir un valor per teclat i assignar-lo a una variable d’entorn. Per tant, les accions algorísmiques anteriors correspondran a la següent codificació en C: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int lecturaMensual; printf(&quot;Introdueix la lectura mensual de la llum (kWh): &quot;); scanf(&quot;%d&quot;, &amp;lecturaMensual); return 0; } És molt important que es vegi clarament què és un algorisme i què és un programa en C. 1.3 Equivalències llenguatge algorísmic vs llenguatge C A continuació s’indiquen algunes de les equivalències existents entre llenguatge algorísmic i el llenguatge de programació C: Llenguatge algorísmic Llenguatge C Segueix unes normes? sí sí Es pot compilar? no sí Es pot executar? no sí Assignació de valors a variables := = Tipus booleà boolean bool Tipus enter integer int Tipus decimal real float Tipus caràcter char char Operador igual = == Operador diferent ≠ != Operador major &gt; &gt; Operador major o igual ≥ &gt;= Operador menor &lt; &lt; Operador menor o igual ≤ &lt;= Operador lògic de conjunció and &amp;&amp; Operador lògic de disjunció or || Operador lògic de negació not ! 1.4 Impressió de valors incorrecta Quan es mostra per pantalla el contingut d’alguna variable amb printf(), és important eliminar el prefix &amp; de la variable. Per exemple, si no ho fem tenim que: #include &lt;stdio.h&gt; int main(int argc, char **argv){ int idAvio; printf(&quot;Introdueix l&#39;identificador d&#39;avió : &quot;); scanf(&quot;%d&quot;, &amp;idAvio); printf(&quot;&gt;&gt; Has escollit l&#39;avió amb id %d \\n&quot;, &amp;idAvio); return 0; } El resultat de l’execució és: Introdueix l&#39;identificador d&#39;avió : 9 &gt;&gt; Has escollit l&#39;avió amb id -1078693464 Per quin motiu obtenim el valor estrany en l’identificador d’avió? Quan fem referència a &amp;idAvio estem obtenint realment la posició de memòria on resideix la variable idAvio, no pas el valor de la variable. Per obtenir el seu valor cal eliminar de dins printf() el prefix &amp; de la variable idAvio: #include &lt;stdio.h&gt; int main(int argc, char **argv){ int idAvio; printf(&quot;Introdueix l&#39;identificador d&#39;avió : &quot;); scanf(&quot;%d&quot;, &amp;idAvio); printf(&quot;&gt;&gt; Has escollit l&#39;avió amb id %d \\n&quot;, &amp;idAvio); return 0; } La sortida generada ara sí és correcta: Introdueix l&#39;identificador d&#39;avió : 9 &gt;&gt; Has escollit l&#39;avió amb id 9 1.5 Com definir un enumeratiu La definició d’un tipus enumeratiu en llenguatge algorísmic es fa de la següent forma: type typeName = {VALUE1, VALUE2, VALUE3, ... , VALUEn}; end type Els elements VALUE1, VALUE2, VALUE3… acaben sent constants, i el valor que de cadascun és: VALUE1 = 0 VALUE2 = 1 VALUE3 = 2 { ... } VALUEn = n-1 Posteriorment no és possible fer un canvi de valor d’aquests elements de tipus enumeratiu. 1.6 Com utilitzar un enumeratiu Una enumeració és una assignació d’un valor enter a la sèrie d’elements que s’hi ha definit, començant pel 0 i incrementant-se en 1 en cada element. Per exemple, podem tenir la següent definició: typedef enum {MALE, FEMALE} tGender; Això significa que MALE == 0 i FEMALE == 1. Si l’ordre de la definició l’haguessis fet al revés, {FEMALE, MALE}, tindríem que FEMALE == 0 i MALE == 1. Una possible forma d’utilitzar els enumeratius es llegir un enter i comparar-lo amb l’element corresponent definit dins de l’enum, per tal de realitzar una acció o una altra. Una possible implementació en llenguatge C seria: #include &lt;stdio.h&gt; typedef enum {MALE, FEMALE} tGender; int main(int argc, char **argv) { tGender gender; printf(&quot;Type patient gender: 0 for MALE, 1 for FEMALE\\n&quot;); scanf(&quot;%d&quot;, &amp;gender); if (gender == MALE) { printf(&quot;Patient gender MALE\\n&quot;); } else { if (gender == FEMALE) { printf(&quot;Patient gender FEMALE\\n&quot;); } else { printf(&quot;Incorrect option\\n&quot;); } } return 0; } 1.7 Especificador d’un enumeratiu Els enumeratius en llenguatge C, enum, utilitzen l’especificador %u independentment del tipus que s’hagi definit per l’enumeratiu. Exemple: #include &lt;stdio.h&gt; typedef enum {PRIVAT, PUBLIC} tTransport; int main(int argc, char **argv) { tTransport tipusTransport; printf(&quot;Amb quin tipus de transport et desplaces a la feina (0=privat, 1=públic) ? : &quot;); scanf(&quot;%u&quot;, &amp;tipusTransport); printf(&quot;Et desplaces a la feina amb transport (0=privat, 1=públic) : &quot;); printf(&quot;%u\\n&quot;, tipusTransport); return 0; } 1.8 Lectura de caràcters en C En el llenguatge C la lectura d’un char pot comportar-se de forma inadequada si prèviament el buffer d’entrada conté algun caràcter previ. Imaginem que volem crear un programa molt senzill que donat un número de DNI i la seva lletra, ens concateni els dos valors i ho mostri per pantalla. Una possible forma d’implementar aquest programa en C seria: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int dniNum; /* número del DNI */ char dniChar; /* lletra del DNI */ printf(&quot;Introdueix el número del DNI: &quot;); scanf(&quot;%d&quot;, &amp;dniNum); printf(&quot;Introdueix la lletra del DNI: &quot;); scanf(&quot;%c&quot;, &amp;dniChar); printf(&quot;\\nEl DNI introduit és: %d-%c\\n&quot;, dniNum, dniChar); return 0; } Què passa si executem aquest codi? Que veiem que es comporta de forma incorrecta, ja que no ens arriba a demanar la lletra del DNI, mostrant directament el resultat: Introdueix el número del DNI: 12345678 Introdueix la lletra del DNI: El DNI introduit és: 12345678- Quan teclegem el primer enter el que fem realment és introduir un número + un intro al final de tot. El número queda assignat a la variable dni_num, i l’intro és llegit com un caràcter i s’assigna a la variable dni_char. Per aquest motiu C interpreta que les dues variables ja tenen valor i finalitza el programa. Com podem solucionar aquest comportament? Buidant l’intro del buffer d’entrada abans de llegir el caràcter, i això ho podem fer amb la comanda getchar(). Aquesta comanda llegeix un caràcter del buffer d’entrada i el buida del buffer. Per tant es pot corregir el programa anterior de la següent forma: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int dni_num; /* número del DNI */ char dni_char; /* lletra del DNI */ printf(&quot;Introdueix el número del DNI: &quot;); scanf(&quot;%d&quot;, &amp;dni_num); getchar(); printf(&quot;Introdueix la lletra del DNI: &quot;); scanf(&quot;%c&quot;, &amp;dni_char); printf(&quot;\\nEl DNI introduit és: %d-%c\\n&quot;, dni_num, dni_char); return 0; } Si ara executem, ja funcionarà com desitgem: Introdueix el número del DNI: 12345678 Introdueix la lletra del DNI: B El DNI introduit és: 12345678-B En cas de necessitat, amb getChar() es pot guardar el caràcter del buffer en una variable, per tal de tractar-lo posteriorment: char nomVariable; nomVariable = getChar(); 1.9 Lectura de float en C El separador de valors decimals (tipus float) en C és el punt, no la coma. Per aquest motiu quan s’introdueix un valor decimal des de teclat, sempre ho farem amb un punt: Exemple: #include &lt;stdio.h&gt; int main(int argc, char **argv) {} /* Variable que contindrà el pes d’una persona */ float pes; /* Lectura de la dada per teclat (el separador de decimals és un . ) */ printf(&quot;Introdueix el pes (kg) d’una persona : &quot;); scanf(&quot;%f&quot;, &amp;pes); /* Es mostra el valor decimal per pantalla */ printf(&quot;Has introduit el pes = %.1f kg.\\n&quot;, pes); return 0; } L’execució serà: Introdueix el pes (kg) d’una persona : 79.440 Has introduit el pes = 79.4 kg. "],
["pac02.html", " 2 PAC02 2.1 Booleans en C 2.2 Booleans definits com a enumeratius 2.3 Constants: define vs const 2.4 Com mostrar el valor d’una constant 2.5 Precisió en variables float 2.6 Semàntica d’una expressió 2.7 Exemples d’expressions", " 2 PAC02 2.1 Booleans en C Alguns punts a considerar amb els booleans en C: Quan utilitzem el tipus bool de C ens cal importar la llibreria &lt;stdbool.h&gt;, ja que el tipus bool no es va definir a les primeres versions del llenguatge C. Els valors que pot prendre una variable booleana en C són false i true. El llenguatge C tracta internament aquests valors com a enters: false correspon a 0 i true a 1. Quan vulguem introduïr el valor d’un booleà per teclat o bé mostrar-lo per pantalla, utilitzarem l’enter 0 per referir-nos a false i 1 per true. L’especificador de tipus dels booleans és %d. Per mostrar el valor d’una variable booleana en C ho podem fer de la següent forma: bool isVocal; printf(&quot;La lletra %c és una vocal (0=false, 1=true) ? %d\\n&quot;, lletra, isVocal); Per llegir un booleà des de teclat, ho faríem de la següent forma: bool variable; scanf(&quot;%d&quot;, &amp;variable); La lectura per teclat d’un booleà, feta tal i com s’indica al punt anterior, generarà un warning del següent tipus: warning: format '%d' expects argument of type 'int *', but argument 2 has type '_Bool *' [-Wformat=]. Aquest avís significa que estem utilitzant un especificador de tipus (%d) diferent del que li correspondria al tipus bool, el qual treballa únicament amb 1 bit. Com que C no disposa de cap especificador de tipus que treballi només amb 1 bit, podem fer dues coses: Utilitzar una variable auxiliar que ens ajudi a fer una conversió intermitja a int, per tal de transformar posteriorment el valor a bool: bool variable; int aux; scanf(&quot;%d&quot;, &amp;aux); variable = aux; Ignorar el warning d’aquesta situació específica: tot i l’avís, el programa es pot compilar i executar. 2.2 Booleans definits com a enumeratius En semestres anteriors de l’assignatura de Fonaments de Programació, s’utilitzava un enumeratiu per definir el tipus booleà: typedef enum {FALSE, TRUE} boolean; Aquesta forma de definir el tipus booleà és obsoleta i no s’utilitza aquest semestre; tal i com s’ha comentat a l’apartat 2.1, els booleans els definirem mitjançant la llibreria &lt;stdbool.h&gt;. Tingueu-ho present quan consulteu PAC1, PR2 i PS3 de semestres anteriors, en els quals s’utilitzava la nomenclatura ara obsoleta. 2.3 Constants: define vs const La definició de constants tant es pot fer amb define com amb const. Tot i això, la forma de comportar-se d’aquestes dues opcions és completament diferent, si ve el resultat final és el mateix: define: quan utilitzem aquesta opció no es desa en cap posició de memòria el valor de la constant. El que es fa realment és que en els passos previs a la pròpia compilació del programa, el preprocessador substitueix totes les referencies del define pel valor indicat. Per exemple, si tenim el següent programa amb una constant creada amb define : #include &lt;stdio.h&gt; #define MIDA 8 char lletres[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;}; int vertical, horitzontal; int main(int argc, char **argv) { /* font: https://en.wikipedia.org/wiki/Chess */ for (vertical=MIDA; vertical&gt;=1; vertical--) { for (horitzontal=0; horitzontal&lt;=MIDA-1; horitzontal++) { printf(&quot;%c%d &quot;, lletres[horitzontal], vertical); } printf(&quot;\\n&quot;); } } Abans de la compilació, el preprocessador entre altres accions elimina comentaris i substitueix totes les referències MIDA per 8: #include &lt;stdio.h&gt; char lletres[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;}; int vertical, horitzontal; int main(int argc, char **argv) { for (vertical=8; vertical&gt;=1; vertical--) { for (horitzontal=0; horitzontal&lt;=8-1; horitzontal++) { printf(&quot;%c%d &quot;, lletres[horitzontal], vertical); } printf(&quot;\\n&quot;); } } Per tant la definició de constants amb define es comporta com si d’un “cercar-reemplaçar” d’un processador de textos es tractés. No es desa cap constant en memòria, però per contra, el programa ocuparà una mica més per la substitució directa de referències que fa; la substitució la fa en tot el programa, no es pot limitar a un àmbit concret (per exemple només dins d’una funció). const: en aquest cas sí que es reserva una posició de memòria. En C es comporta igual com si fos una variable, però la qual únicament funciona en mode lectura: no li podem modificar el valor. A més, const ens permet també dir quin tipus de valor tindrà la constant: si és de tipus float, int, char… amb el que aquest fet ens dóna un punt addicional de control, ja que ens assegurem que el tipus de valor assignat serà el correcte pel programa. Amb aquest tipus de definició de constant, l’exemple anterior quedaria de la següent forma: #include &lt;stdio.h&gt; const int MIDA 8 char lletres[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;}; int vertical, horitzontal; int main(int argc, char **argv) { /* La constant MIDA està desada en memòria */ printf(&quot;posició en memòria de la constant MIDA : %p \\n&quot;, &amp;MIDA); for (vertical=MIDA; vertical&gt;=1; vertical--) { for (horitzontal=0; horitzontal&lt;=MIDA-1; horitzontal++) { printf(&quot;%c%d &quot;, lletres[horitzontal], vertical); } printf(&quot;\\n&quot;); } } Com es pot veure, és possible obtinir l’adreça en memòria on es desa la constant MIDA. En aquest cas, sí que pots definir una constant amb const i fer que només afecti un àmbit determinat (per exemple, que la constant estigui definida únicament dins d’una funció). Aquestes són les principals diferències entre define i const a l’hora de definir una constant; define es va crear molt abans que no la sentència const, amb el que és un habit força habitual decantar-se per aquesta opció per temes més històrics. 2.4 Com mostrar el valor d’una constant En C podem mostrar per pantalla el valor d’una constant definida amb #define mitjançant printf(). Exemple: #include &lt;stdio.h&gt; #define PARAULA &quot;world&quot; #define ANY 2019 #define EXCLAMACIO &#39;!&#39; int main(int argc, char **argv) { printf(&quot;hello %s and happy %d %c\\n&quot;, PARAULA, ANY, EXCLAMACIO); return 0; } El resultat que es mostrarà per pantalla serà: hello world and happy 2019 ! 2.5 Precisió en variables float Hi ha alguns valors decimals determinats que no es poden representar de forma precisa en una variable de tipus float. La millor solució pels casos que tractem és arrodonir al número de decimals que realment necessitem. Si en canvi volem sí o sí treballar amb tots els decimals, podem optar per utilitzar un tipus de dada que tingui major precisió que float: double. Per exemple, el següent programa retorna el resultat esperat si es desa en un double, i no així si es fa en un float: #include &lt;stdio.h&gt; int main(int argc, char **argv) { float num1; float num2; float resultat1; double resultat2; num1 = 1.3; num2 = 17; resultat1 = num1 + num2; printf(&quot;resultat amb float: %f\\n&quot;, resultat1); resultat2 = num1 + num2; printf(&quot;resultat amb double: %f\\n&quot;, resultat2); return 0; } La sortida que genera és: resultat amb float: 18.299999 resultat amb double: 18.300000 2.6 Semàntica d’una expressió Si recordem el que es comenta al punt 3.2. Semàntica d’una expressió del mòdul de la xWiki Tipus bàsics de dades, hem d’aconseguir queles expressions i comparacions realitzades als algorismes siguin semànticament correctes. Amb un exemple es veurà més clar: tenim el següent algorisme que indica si una persona és major d’edat. Fixeu-vos que l’expressió realitza una comparació entre dos enters: la variable edat i el número 17. var edat: int; majorEdat: boolean; end var algorithm serMajorEdat writeString(&quot;Introdueix edat del conductor :&quot;); edat := readInteger(); majorEdat := (edat &gt; 17); writeString(&quot;El conductor és major d&#39;edat? :&quot;); writeBoolean(majorEdat); end algorithm Aquesta expressió és semànticament correcta. En canvi, imaginem ara que el nostre algorisme accepta decimals per l’edat; per exemple, 19.5 indicaria que l’edat és de 19 anys i 6 mesos. Així tenim el següent plantejament, on ara la variable edat és de tipus real: var edat: real; majorEdat: boolean; end var algorithm serMajorEdat writeString(&quot;Introdueix edat del conductor :&quot;); edat := readReal(); majorEdat := (edat &gt; 17); writeString(&quot;El conductor és major d&#39;edat? :&quot;); writeBoolean(majorEdat); end algorithm L’algorisme ara no és correcte ja que conté una expressió semànticament incorrecta, en la qual es compara edat (real) amb 17 (enter). Per solucionar-ho, podem utilitzar alguna de les funcions de conversió comentades a l’apartat 4. Funcions de conversió de tipus del mateix mòdul: {opció 1: fem que els dos valors siguin de tipus enter} majorEdat := (realToInteger(edat) &gt; 17); {opció 2: fem que els dos valors siguin de tipus real} majorEdat := (edat &gt; integerToReal(17)); 2.7 Exemples d’expressions 2.7.1 Exemple 1: esParell Imaginem que ens demanen un algorisme que indiqui si un número és parell. Una possible solució seria: algorithm esParell var numero: integer; isParell: boolean; end var writeString(&quot;Introdueix un número : &quot;); numero:= readInteger(); isParell:= (numero mod 2 = 0); writeString(&quot;El numero &quot;); writeInteger(numero); writeString(&quot; és parell? &quot;); writeBoolean(isParell); end algorithm La variable isParell prendrà el valor TRUE si el número es parell i FALSE en cas contrari. No ha calgut utilitzar cap estructura if-else per resoldre l’algorisme. Una possible forma de codificar-ho en llenguatge C és: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; int main(int argc, char **argv) { int numero; bool isParell; printf(&quot;Introdueix un número : &quot;); scanf(&quot;%d&quot;, &amp;numero); isParell = (numero % 2 == 0); printf(&quot;El número %d és parell? (0=FALSE, 1=TRUE) : %d \\n&quot;, numero, isParell); return 0; } 2.7.2 Exemple 2: capDeSetmana Imaginem que volem fer un programa molt senzill que ens digui si avui és cap de setmana o no. El seu algorisme seria el següent: type dies = {DILLUNS, DIMARTS, DIMECRES, DIJOUS, DIVENDRES, DISSABTE, DIUMENGE}; end type algorithm capDeSetmana var esCapDeSetmana: boolean; diaSetmana: dies; end var writeString(&quot;Quin dia de la setmana és avui ?\\n&quot;); writeString(&quot;Per DILLUNS tecleja 0\\n&quot;); writeString(&quot;Per DIMARTS tecleja 1\\n&quot;); writeString(&quot;Per DIMECRES tecleja 2\\n&quot;); writeString(&quot;Per DIJOUS tecleja 3\\n&quot;); writeString(&quot;Per DIVENDRES tecleja 4\\n&quot;); writeString(&quot;Per DISSABTE tecleja 5\\n&quot;); writeString(&quot;Per DIUMENGE tecleja 6\\n&quot;); diaSetmana:= readInteger(); esCapDeSetmana:= (diaSetmana = DISSABTE or diaSetmana = DIUMENGE); writeString(&quot;Avui és cap de setmana?&quot;); writeBool(esCapDeSetmana); end algorithm La variable boolean esCapDeSetmana prendrà el valor de true o false en funció del resultat d’avaluar l’expressió. No és necessari la utilització d’estructures condicionals if-else que veurem més endavant en el curs. Una possible forma de codificar-ho en llenguatge C és: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; typedef enum {DILLUNS, DIMARTS, DIMECRES, DIJOUS, DIVENDRES, DISSABTE, DIUMENGE} dies; int main(int argc, char **argv) { bool esCapDeSetmana; dies diaSetmana; printf(&quot;\\nQuin dia de la setmana és avui ?\\n&quot;); printf(&quot;Per DILLUNS tecleja 0\\n&quot;); printf(&quot;Per DIMARTS tecleja 1\\n&quot;); printf(&quot;Per DIMECRES tecleja 2\\n&quot;); printf(&quot;Per DIJOUS tecleja 3\\n&quot;); printf(&quot;Per DIVENDRES tecleja 4\\n&quot;); printf(&quot;Per DISSABTE tecleja 5\\n&quot;); printf(&quot;Per DIUMENGE tecleja 6\\n&quot;); scanf(&quot;%u&quot;, &amp;diaSetmana); esCapDeSetmana = (diaSetmana == DISSABTE || diaSetmana == DIUMENGE); printf(&quot;Avui és cap de setmana (0 == false, 1 == true) ? %d\\n&quot;, esCapDeSetmana); return 0; } Varis punts a considerar: Recordem que inicialment en C no existia el tipus booleà. Per poder utilitzar bool, i els valors true i false ens cal importar prèviament la llibreria &lt;stdbool.h&gt;. L’especificador de tipus d’un bool és %d. Quan definim una variable de tipus enum, utilitzem l’especificador de tipus %u. Ho podríem fer com a %d, però us retornarà un warning tot i que el resultat sigui correcte. El tipus %u és igual que un enter %d però sense signe: això significa que amb %d podem tractar valors negatius com -12 i amb %u això no és possible, però com que sabem que els valors que pot prendre un enum sempre seran &gt;= 0, ens convé utilitzar %u. Per les particularitats dels bool en el llenguatge de programació C que ja hem comentat anteriorment, l’entrada i sortida de valors d’un boolean serà numèrica. Per facilitar la comprensió podem mostrar per pantalla un literal que ens indiqui que 0 equival a false i 1 a true. 2.7.3 Exemple 3: esVocal Exemple: volem fer un programa que, entrat un caràcter pel canal d’entrada, ens indiqui si es tracta o no d’una vocal. Una possible solució per l’algorisme és la següent: var lletra: char; isVocal: boolean; end var algorithm trobaVocal writeString(&quot;Tecleja una lletra :&quot;); lletra := readChar(); { en aquest exemple només tractem les vocals minúscules } isVocal := lletra = &#39;a&#39; or lletra = &#39;e&#39; or lletra = &#39;i&#39; or lletra = &#39;o&#39; or lletra = &#39;u&#39;; writeString(&quot;La lletra &quot;); writeChar(lletra); writeString(&quot; és una vocal? &quot;); writeBoolean(isVocal); end algorithm Com es pot veure el plantejament de l’algorisme és: Llegim un caràcter des del canal d’entrada. Comparem el caràcter amb a, e, i, o, u. Si coincideix amb alguna d’aquestes vocals, la variable isVocal := true. Si no coincideix amb cap de les vocals, la variable isVocal := false. Es mostra el resultat per pantalla. Com ho podem traduir a llenguatge C? Una possible opció és: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; int main(int argc, char **argv) { char lletra; bool isVocal; printf(&quot;Introdueix una lletra : &quot;); scanf(&quot;%c&quot;, &amp;lletra); /* en aquest exemple només tractem les vocals minúscules */ isVocal = lletra == &#39;a&#39; || lletra == &#39;e&#39; || lletra == &#39;i&#39; || lletra == &#39;o&#39; || lletra == &#39;u&#39;; printf(&quot;La lletra %c és una vocal (0=FALSE, 1=TRUE) ? %d\\n&quot;, lletra, isVocal); return 0; } 2.7.4 Exemple 4: votacions Imaginem que hem de fer un programa que validi si una persona pot anar a votar o no; la condició que ens diuen que cal complir és que la persona sigui major d’edat i a més estigui al cens electoral de la localitat on està votant. L’algorisme podria ser el següent: algorithm votacions var isMajorEdat: boolean; isCensat: boolean; isVotar: boolean; end var writeString(&quot;Ets major d&#39;edat (0=FALSE, 1=TRUE) ? : &quot;); isMajorEdat := readBoolean(); writeString(&quot;Estàs al cens electoral (0=FALSE, 1=TRUE) ? : &quot;); isCensat := readBoolean(); { expressió } isVotar := isMajorEdat and isCensat; writeString(&quot;Pots anar a votar (0=FALSE, 1=TRUE) :&quot;); writeBoolean(isVotar); end algorithm Una possible implementació en C seria: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; int main(int argc, char **argv) { bool isMajorEdat; bool isCensat; bool isVotar; printf(&quot;Ets major d&#39;edat (0=FALSE, 1=TRUE) ? : &quot;); scanf(&quot;%d&quot;, &amp;isMajorEdat); printf(&quot;Estàs al cens electoral (0=FALSE, 1=TRUE) ? : &quot;); scanf(&quot;%d&quot;, &amp;isCensat); { expressió } isVotar = isMajorEdat &amp;&amp; isCensat; printf(&quot;Pots anar a votar (0=FALSE, 1=TRUE) : %d\\n&quot;, isVotar); return 0; } Un possible execució d’aquest exemple seria: Ets major d&#39;edat (0=FALSE, 1=TRUE) ? : 1 Estàs al cens electoral (0=FALSE, 1=TRUE) ? : 0 Pots anar a votar (0=FALSE, 1=TRUE) : 0 2.7.5 Exemple 5: ginTonicPreparation Imaginem que volem preparar un gintònic. Sabem el volum de ginebra i de tònica que utilitzarem, i quina és la capacitat de la copa de baló que el contindrà. Hem vist una oferta per internet i hem comprat glaçons metàl·lics d’acer inoxidable… però se’ns ha anat una mica el cap i n’hem comprat un total de 20 unitats. Volem fer un programa que, utilitzant únicament expressions, ens digui si podem preparar o no el gintònic en funció del número de glaçons que li volem posar: si el nombre de glaçons caben dins de la copa, retornarà true. en cas contrari, retornarà false. Per tant el que ha de fer el nostre programa bàsicament és validar si el volum de ginebra + tònica + (glaço) * número de glaçons supera o no el volum de la copa. L’algorisme podria ser el següent: const GIN: real = 50.0; { in ml } TONIC: real = 200.0; { in ml } GLASS: real = 620.0; { in ml } METAL_ICE_CUBE: real = 42.875; { in ml } end const algorithm ginTonicPreparation var numMetalIceCubes: integer; isPossible: boolean; end var writeString(&quot;Number of metal ice cubes ? (integer) : &quot;); numMetalIceCubes:= readInteger(); isPossible:= (GLASS ≥ (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes)); writeString(&quot;Can you make a gin &amp; tonic? : &quot;); writeBoolean(isPossible); end algorithm L’expressió que dóna valor a isPossible s’ocupa d’avaluar el volum de la copa respecte el resultant de ginebra, tònica i glaçons. La seva traducció a C podria ser: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #define GIN 50.0 /* in ml */ #define TONIC 200.0 /* in ml */ #define GLASS 620.0 /* in ml */ #define METAL_ICE_CUBE 42.875 /* in ml */ int main(int argc, char **argv) { int numMetalIceCubes; bool isPossible; printf(&quot;Number of metal ice cubes ? (integer) : &quot;); scanf(&quot;%d&quot;, &amp;numMetalIceCubes); isPossible = GLASS &gt;= (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes); printf(&quot;Can you make a gin &amp; tonic? (0=FALSE, 1=TRUE) : %d\\n&quot;, isPossible); return 0; } Per realitzar el càlcul en C també s’ha utilitzat una expressió. 2.7.6 Exemple 6: ginTonicFreeMl Anem a evolucionar l’exemple anterior del gintònic: imaginem ara que volem que el nostre programa ens digui el volum (en mililitres) que queda lliure a la copa una vegada posat un determinat nombre de glaçons. L’algorisme quedaria de la següent forma: const GIN: real = 50.0; { in ml } TONIC: real = 200.0; { in ml } GLASS: real = 620.0; { in ml } METAL_ICE_CUBE: real = 42.875; { in ml } end const algorithm ginTonicFreeMl var numMetalIceCubes: integer; volumeFree: real; end var writeString(&quot;Number of metal ice cubes ? (integer) : &quot;); numMetalIceCubes:= readInteger(); volumeFree:= GLASS - (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes); writeString(&quot;How many free ml in the glass? : &quot;); writeReal(volumeFree); end algorithm I la codificació en C : #include &lt;stdio.h&gt; #define GIN 50.0 /* in ml */ #define TONIC 200.0 /* in ml */ #define GLASS 620.0 /* in ml */ #define METAL_ICE_CUBE 42.875 /* in ml */ int main(int argc, char **argv) { int numMetalIceCubes; float volumeFree; printf(&quot;Number of metal ice cubes ? (integer) : &quot;); scanf(&quot;%d&quot;, &amp;numMetalIceCubes); volumeFree = GLASS - (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes); printf(&quot;How many free ml in the glass ? : %.3f ml \\n&quot;, volumeFree); return 0; } 2.7.7 Exemple 7: scoutingBasquet Imaginem que fem tasques d’scouting per les seccions de bàsquet femení i masculí del nostre club, i ens han encarregat cobrir alguna de les tres places següents: Per l’equip femení: una pivot que com a mínim faci 195cm d’alçada. Per l’equip femení: una base, l’alçada de la qual sigui inferior a 170cm. Per l’equip masculí: un base que sigui més alt de 175cm però a la vegada que no superi els 190cm. El nostre programa demanarà per teclat si es tracta d’una jugadora o un jugador, i quina és la seva alçada. A continuació amb expressions avaluarà les condicions introduides i si les compleix per alguna de les tres places disponibles, l’escollirà (isDrafted). Una possible forma de codificar en C aquest programa seria: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; typedef enum {MALE, FEMALE} tGender; int main(int argc, char **argv) { bool isPointGuard; /* Point Guard = base */ bool isCenter; /* Center = pivot */ bool isDrafted; int height; tGender gender; printf(&quot;Gender (0=MALE, 1=FEMALE) : &quot;); scanf(&quot;%u&quot;, &amp;gender); printf(&quot;Heigth (integer value) : &quot;); scanf(&quot;%d&quot;, &amp;height); /* Primer mirem si la posició de base femení o masculí la podem cobrir o no */ isPointGuard = (height &lt; 170 &amp;&amp; (gender == FEMALE)) || (height &lt; 190 &amp;&amp; height &gt; 175 &amp;&amp; (gender == MALE)); /* A continuació comprovem si es tracta de la pívot femenina que busquem */ isCenter = (height &gt;= 195 &amp;&amp; (gender == FEMALE)); /* Només que es compleixi alguna de les dues expressions anteriors (que isPointGuard sigui TRUE o que isCenter sigui TRUE), el jugador/a serà escollit per formar part de les nostres seccions de bàsquet */ isDrafted = isPointGuard || isCenter; printf(&quot;\\nIs drafted (0=FALSE, 1=TRUE) ? : &quot;); printf(&quot;%d\\n&quot;, isDrafted); } Fixeu-vos que isPointGuard i isCenter són variables de tipus bool, ja que l’avaluació de les expressions també serà de tipus bool. Hi poden haver altres codificacions igual de vàlides, aquesta no és la única solució possible. Prova d’Avaluació Continua↩ Pràctica↩ Prova de Síntesi↩ "],
["pac03.html", " 3 PAC03 3.1 Com declarar un vector en llenguatge algorísmic 3.2 Significat dels arguments del main 3.3 Assignar valors a un vector 3.4 Stack smashing detected 3.5 Concatenació en llenguatge algorísmic 3.6 Importància dels tipus utilitzats en llenguatge C 3.7 Exemple: notaFinal", " 3 PAC03 3.1 Com declarar un vector en llenguatge algorísmic Quan es declara un vector en llenguatge algorísmic no cal declarar una variable per cadascuna de les posicions d’aquest vector. Per exemple, si volem un algorisme que sumi tres enters continguts dins d’un vector podem fer el següent: const NUM_ENTERS: integer = 3; end const algorithm sumaEnters var vectorEnters: vector[NUM_ENTERS] of integer; sumaEnters: integer; end var vectorEnters[1] := 13; vectorEnters[2] := 24; vectorEnters[3] := 2; { Com es pot veure, accedim directament a les posicions del vector } { en comptes de definir una variable per cada posició. } sumaEnters := vectorEnters[1] + vectorEnters[2] + vectorEnters[3]; { Cal recordar també que en llenguatge algorísmic, en un vector de mida n } { la primera posició del vector és la 1 i la darrera la n; en canvi en llenguatge C } { la primera sempre és la 0 i l&#39;última la n-1. } writeString(&quot;La suma dels 3 enters del vector és : &quot;); writeInteger(sumaEnters); end algorithm 3.2 Significat dels arguments del main La principal diferència entre la definició main(int argc, char **argv) i main() és que la primera opció està preparada per rebre arguments quan s’executa el programa i no així la segona. Per exemple, si tens el següent programa compilat en C i li passes una sèrie d’arguments des de la línia de comandes: $&gt; programa a1 a2 a3 Amb el main definit com a main(int argc, char **argv) pots accedir des de dins del programa a tots els arguments passats; així tindràs que: argc = 4 argv[0] = &quot;programa&quot; argv[1] = &quot;a1&quot; argv[2] = &quot;a2&quot; argv[3] = &quot;a3&quot; El propi sistema operatiu s’ocupa de donar-li el valor a l’argument int argc (número total d’arguments inclòs el nom del programa), amb el que únicament t’has de preocupar de passar els arguments . D’altra banda, argv és un array de punters on cadascun d’ells apunta a un argument format per una cadena de caràcters; així argv contindrà a cadascuna de les seves posicions els arguments passats des de línia de comandes, i en la posició 0 el propi nom del programa. Si en canvi tens definit el programa com a main(), simplement no tens forma d’accedir als arguments que li puguis arribar a passar. Hi ha moltes vegades que les dades les pots tenir ja definides dins del propi programa o les vagis a consultar a una font externa, amb el que no tenir la capacitat de processar arguments no suposa cap impediment a l’hora d’executar el teu programa. 3.3 Assignar valors a un vector La lectura i assignació de valors a un vector es realitza de la següent forma en llenguatge algorísmic: const MAX_TEMP: integer = 2; end const algorithm lecturaTemperatures var vTemperatures: vector[MAX_TEMP] of float; end var writeString(&quot;Introdueix la lectura 1 : &quot;); vTemperatures[1] := readReal(); writeString(&quot;Introdueix la lectura 2 : &quot;); vTemperatures[2] := readReal(); writeString(&quot;Els valors introduïts han estat : &quot;); writeString(&quot;&gt; Valor de la posició &quot;); writeInteger(1); writeString(&quot; : &quot;); writeReal(vTemperatures[1]); writeString(&quot;&gt; Valor de la posició &quot;); writeInteger(2); writeString(&quot; : &quot;); writeReal(vTemperatures[2]); end algorithm I en llenguatge C: #include &lt;stdio.h&gt; #define MAX_TEMP 2 int main(int argc, char **argv) { float vTemperatures[MAX_TEMP]; int i; printf(&quot;Introdueix la lectura 1 : &quot;); scanf(&quot;%f&quot;, &amp;vTemperatures[0]); printf(&quot;Introdueix la lectura 2 : &quot;); scanf(&quot;%f&quot;, &amp;vTemperatures[1]); printf(&quot;&gt; Valor de la posició %d : %.1f \\n&quot;, 0, vTemperatures[0]); printf(&quot;&gt; Valor de la posició %d : %.1f \\n&quot;, 1, vTemperatures[1]); return 0; } Cal remarcar una diferència important: En llenguatge algorísmic les posicions del vector van des de la 1 fins a la N, sent N el número total d’elements del vector. En llenguatge C, van des de la 0 fins a la N-1, sent N el número total d’elements del vector. 3.4 Stack smashing detected Aquest missatge d’error es produeix quan s’intenta accedir/operar amb una posició d’un vector que no l’hem definit prèviament. Es pot donar per diferents situacions que acaben generant el mateix problema. Cas 1: es defineix un vector de n-posicions, però en comptes de començar per la posició 0 ho fem per la 1. Això és incorrecte: recordeu que en C la posició inicial d’un vector sempre és la 0, i la final sempre és mida-1. Exemple, per un vector de 3 posicions tindrem: int vector1[3]; vector1[1] = 13; /* Posició del vector1 vàlida */ vector1[2] = 24; /* Posició del vector1 vàlida */ vector1[3] = 48; /* Posició del vector1 no vàlida! */ /* En canvi la posició 0 del vector, * que tenim disponible no l&#39;hem utilitzat! */ Cas 2: es defineix un vector amb menys posicions de les que necessitem. Per exemple, si tenim: int vector2[2]; Significa que les posicions reservades en memòria per aquest vector són: vector2[0] = 10; /* Posició del vector2 vàlida */ vector2[1] = 13; /* Posició del vector2 vàlida */ vector2[2] = 24; /* Posició del vector2 no vàlida! */ Per tant qualsevol operació amb vector2[2] ens generarà l’error indicat. Si volem que el vector contingui 3 elements només cal definir correctament la seva mida: int vector2[3]; 3.5 Concatenació en llenguatge algorísmic A diferència del llenguatge C, en notació algorísmica no està contemplat l’ús d’especificadors que permetin fer concatenacions entre cadenes de caràcters, enters, decimals, etc. Per tant en llenguatge algorísmic cal trencar els strings amb fragments més petits i que facin referència únicament a un tipus de dades. Per exemple, si es vol mostrar per pantalla el missatge “L’empleat que cobra més és Marta, i la seva nòmina és 4675.30 €.”, ho farem de la següent forma: writeString(&quot;L&#39;empleat que cobra més és &quot;); writeString(nomEmpleat); writeString(&quot;, i la seva nòmina és &quot;); writeReal(nomina); writeString(&quot; €.&quot;); En llenguatge C equivaldria a: printf(&quot;L&#39;empleat que cobra més és %s, i la seva nòmina és %.2f €.&quot;, nomEmpleat, nomina); 3.6 Importància dels tipus utilitzats en llenguatge C El resultat de les operacions en llenguatge C depèn del tipus de variable definit i dels tipus de valors utilitzats. A continuació s’exposen tres casos que, segons el tipus que s’hagi definit en les variables utilitzades, donarà un resultat o un altre: Cas 1: #include &lt;stdio.h&gt; int main() { int a; int b; int c; int m; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); scanf(&quot;%d&quot;, &amp;c); m=(a+b+c)/3; printf(&quot;%d&quot;, m); return 0; } En aquest cas si donem els valors a = 1, b = 3, c = 4, el resultat és m = 2. El resultat de la divisió serà un enter, ja que tant numerador com denominador estan formats per enters. El resultat enter es desa en una variable entera, i per pantalla obtindrem: 2. Cas 2: #include &lt;stdio.h&gt; int main() { int a; int b; int c; float m; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); scanf(&quot;%d&quot;, &amp;c); m=(a+b+c)/3; printf(&quot;%f&quot;, m); return 0; } Igual que en el cas anterior, el numerador i el denominador de la divisió estan formats per enters, amb el que el resultat serà un enter. En aquest cas el resultat enter el desem en una variable de tipus float, amb el que C mostrarà el resultat amb decimals: 2.000000 Cas 3: #include &lt;stdio.h&gt; int main() { int a; int b; int c; float m; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); scanf(&quot;%d&quot;, &amp;c); m=(a+b+c)/3.0; printf(&quot;%f&quot;, m); return 0; } En aquest cas el resultat de la divisió serà un decimal, ja que el denominador conté un decimal (en aquest cas 3.0). El resultat amb decimals es guarda en una variable de tipus float, i per pantalla es mostrarà : 2.666667. 3.7 Exemple: notaFinal En aquesta PAC03 es comencen a tractar dos nous aspectes: els condicionals i els vectors, dins dels quals hi contemplem també els strings. El següent exemple contempla bastants punts dels que es comenten als mòduls de teoria per la PAC03, amb el que segurament aquest exemple serà força més dens que no la pròpia PAC03. Per tant, si algun aspecte costa d’entendre inicialment no us preocupeu, és normal. He afegit comentaris detallats dins del propi exemple, per tal que sigui el més entenedor possible. El següent exemple calcula la nota final d’una assignatura en funció d’una sèrie de condicionals i d’operacions: #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Exemple: * * Volem un programa que calculi la nota final * d&#39;una assignatura. La nota final es calcula a partir * de l&#39;AC (Avaluació continua) i la nota de la Pràctica: * * Nota final = 30% AC + 70% Pràctica * * Una vegada entrades totes les notes, si se&#39;n * detecta alguna que sigui incorrecta (fora del * rang [0.0 a 10.0]), es mostrarà un missatge * informatiu per pantalla i no es realitzarà cap * més operació. * * L&#39;AC està formada per 3 PAC: PAC1, PAC2, PAC3. * La nota de l&#39;AC es calcula mitjançant la * mitjana de les 3 PAC. * * Si la nota de l&#39;AC és inferior a 4, no cal * realitzar cap càlcul: l&#39;assignatura queda suspesa. * * Si la nota de l&#39;AC és superior o igual a 4, es * calcula la nota final juntament amb la nota de * la Pràctica. * * La nota final es mostrarà en format &quot;grade letters&quot;, * segons la següent relació: * * MH: 10 * A: de 9.0 a 9.9 * B: de 7.0 a 8.9 * C+: de 5.0 a 6.9 * C-: de 3.0 a 4.9 * D: de 0.0 a 2.9 * * Els punts que tracta aquest exemple: * - definició de vectors * - utilització del condicional if-else * - condicionals if-else aniuats * - assignació d&#39;un string a una variable amb strcpy * - reserva espai pel finalitzador &#39;\\0&#39; */ #define PAC1 0 #define PAC2 1 #define PAC3 2 #define PRA 3 #define MAX_ACTIVITATS 4 #define MAX_CHARS 2+1 /* el +1 correspon al finalitzador &#39;\\0&#39; */ #define PES_AC 0.3 /* AC 30% pes de la nota final */ #define PES_PRA 0.7 /* PRA 70% pes de la nota final */ int main(int argc, char **argv) { /* Vector que conté les notes de * totes les activitats del curs */ float notes[MAX_ACTIVITATS]; /* Nota d&#39;avaluació continua: equival * a la mitjana de les 3 PAC */ float notaAC; float notaFinalNumerica; /* String que conté la nota final * de l&#39;assignatura (MH, A, B...) */ char notaFinal[MAX_CHARS]; /* Es demana des de teclat les notes * de les 3 PAC i de la PRA */ printf(&quot;Nota PAC1 : &quot;); /* L&#39;assignació d&#39;un valor es pot * fer directament sobre una posició * del vector */ scanf(&quot;%f&quot;, &amp;notes[PAC1]); /* Idem per la resta d&#39;activiats */ printf(&quot;Nota PAC2 : &quot;); scanf(&quot;%f&quot;, &amp;notes[PAC2]); printf(&quot;Nota PAC3 : &quot;); scanf(&quot;%f&quot;, &amp;notes[PAC3]); printf(&quot;Nota PRA : &quot;); scanf(&quot;%f&quot;, &amp;notes[PRA]); /* Primer de tot, comprovem que * totes les notes del vector estiguin * dins del rang [0.0 .. 10.0] */ if (notes[PAC1] &gt; 10.0 || notes[PAC2] &gt; 10.0 || notes[PAC3] &gt; 10.0 || notes[PRA] &gt; 10.0 || notes[PAC1] &lt; 0.0 || notes[PAC2] &lt; 0.0 || notes[PAC3] &lt; 0.0 || notes[PRA] &lt; 0.0) { printf(&quot;\\n&gt;&gt; Error detectat en una o més notes:&quot;); printf(&quot;\\n&gt;&gt; S&#39;atura el càlcul de la nota final.\\n&quot;); } else { /* En aquest punt sabem que totes les notes * estan dins del rang [0.0 .. 10.0] */ /* Comprovem ara que la mitjana de les 3 PAC * no sigui inferior a 4 */ notaAC = (notes[PAC1] + notes[PAC2] + notes[PAC3]) / 3; if (notaAC &lt; 4) { /* Per donar millor visibilitat, mostrem només * el primer decimal de les notes numèriques */ printf(&quot;\\n&gt;&gt; Nota mínima d&#39;AC insuficient: %.1f&quot;, notaAC); printf(&quot;\\n&gt;&gt; S&#39;atura el càlcul de la nota final.\\n&quot;); } else { /* En aquest punt totes les notes són correctes, * per tant es pot començar amb el càlcul de la * nota final */ notaFinalNumerica = notaAC * PES_AC + notes[PRA] * PES_PRA; /* Ara falta saber quina &quot;grade letter&quot; correspon * a la notaFinalNumerica calculada; ho solucionem * amb nous if-else aniuats */ if (notaFinalNumerica &lt;= 2.9) { /* Per assignar un string a una variable * de tipus string, utilitzem la comanda * strcpy, no pas &#39;=&#39; */ strcpy(notaFinal, &quot;D&quot;); } else { if (notaFinalNumerica &lt;= 4.9) { strcpy(notaFinal, &quot;C-&quot;); } else { if (notaFinalNumerica &lt;= 6.9) { strcpy(notaFinal, &quot;C+&quot;); } else { if (notaFinalNumerica &lt;= 8.9) { strcpy(notaFinal, &quot;B&quot;); } else { if (notaFinalNumerica &lt;= 9.9) { strcpy(notaFinal, &quot;A&quot;); } else { strcpy(notaFinal, &quot;MH&quot;); } } } } } /* Per finalitar, mostrem tots els resultats * calculats per pantalla */ printf(&quot;\\n&gt;&gt; Nota AC: %.1f&quot;, notaAC); printf(&quot;\\n&gt;&gt; Nota PRA: %.1f&quot;, notes[PRA]); printf(&quot;\\n&gt;&gt; Nota final: %s (%.1f)\\n&quot;, notaFinal, notaFinalNumerica); } } return 0; } "],
["pac04.html", " 4 PAC04 4.1 Com tractar elements d’un vector amb un bucle 4.2 Entrada continua de valors amb un bucle 4.3 Com tractar valors en múltiples vectors 4.4 Definició chars vs strings", " 4 PAC04 4.1 Com tractar elements d’un vector amb un bucle Imaginem que ens demanen un programa que realitzi dues accions: llegir des del canal estàndard d’entrada (teclat) 5 números i introduir-los en un vector d’enters. mostrar pel canal estàndard de sortida (pantalla) els 5 números del vector d’enters del punt anterior. L’algorisme podria ser el següent: const MAX_NUMS: integer = 5; end const algorithm vectorDeNumeros var i: integer; vectorNumeros: vector[MAX_NUMS] of integer; end var { Assignar valor a cada posició del vector des de teclat } for i := 1 to MAX_NUMS do writeString(&quot;Introdueix número : &quot;); vectorNumeros[i] := readInteger(); end for { Mostrar per pantalla quin valor hi ha a cada posició del vector:} { es podria haver utilitzat un bucle for, però ho implemento amb un while } { perquè es vegi que també és possible fer-ho } i := 1; while i ≤ MAX_NUMS do writeString(&quot;La posició &quot;); writeInteger(i); writeString(&quot; del vector conté el número &quot;); writeInteger(vectorNumeros[i]); { És molt important que amb un bucle while incrementem la variable que utilitzem d&#39;índex } { abans de finalitzar tot el bloc d&#39;instruccions que executa, ja que en cas contrari el seu } { valor sempre seria de i == 1 } i := i+1; end while end algorithm Com es pot veure, per tal d’insertar/llegir els elements d’un vector aprofitem la iteració d’un bucle per recorre’ls tots, un a un, mitjançant una variable que utilitzem d’índex (en aquests casos, la variable i). La traducció a C de l’algorisme podria ser així: #include &lt;stdio.h&gt; #define MAX_NUMS 5 int main(int argc, char **argv) { int vectorNumeros [MAX_NUMS]; int i; /* Assignar valor a cada posició del vector des de teclat */ for (i = 0; i &lt; MAX_NUMS; i++) { printf(&quot;Introdueix número : &quot;); scanf(&quot;%d&quot;, &amp;vectorNumeros[i]); } /* Mostrar per pantalla quin valor hi ha a cada posició del vector: * es podria haver utilitzat un bucle for, però ho implemento amb un while * perquè es vegi que també és possible fer-ho */ i = 0; while (i &lt; MAX_NUMS) { printf(&quot;\\nLa posició %d del vector conté el número %d&quot;, i, vectorNumeros[i]); /* És molt important que amb un bucle while incrementem la variable que utilitzem d&#39;índex * abans de finalitzar tot el bloc d&#39;instruccions que executa, ja que en cas contrari el seu * valor sempre seria de i == 0 */ i = i+1; } } 4.2 Entrada continua de valors amb un bucle Imaginem que hem de fer un programa que vagi demanant números indefinidament i que finalitzi únicament en el cas que el número introduit sigui parell. Una possible forma de fer-ho utilitzant un únic while seria la següent: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int numero; /* Demanem una primera vegada el número a validar * just abans d&#39;entrar al bucle */ printf(&quot;Tecleja un número parell : &quot;); scanf(&quot;%d&quot;, &amp;numero); while ((numero % 2) != 0) { /* Entra al bucle en el cas que el * residu de la divisió per 2 sigui * diferent de 0 (equival a no ser parell) */ printf(&quot;El número %d no és parell !!\\n&quot;, numero); /* Tornem a demanar un número, ara ja * dins del bucle */ printf(&quot;Tecleja un número parell : &quot;); scanf(&quot;%d&quot;, &amp;numero); } printf(&quot;El número %d és parell.\\n&quot;, numero); return 0; } Abans d’entrar al bucle demanem un el valor de la variable numero. A continuació s’utilitza la condició de bucle per validar si es tracta d’un número parell o senar: Si el número es parell, no s’entra al bucle. Si el número és senar es compleix la condició del bucle i s’hi entra; dins del bucle es torna a demanar un valor per la variable numero i es torna a actuar igual que abans: Si és senar, no se surt del bucle. En cas contrari, se surt del bucle. Finalment es mostra per pantalla el missatge “El número X és parell”. 4.3 Com tractar valors en múltiples vectors Imaginem que volem introduir per teclat una sèrie de dades dels treballadors de la nostra empresa: dni, dies d’antiguitat i sou brut anual. Aquestes dades les introduïrem en tres vectors diferents: un pels DNI, l’altre per l’antiguitat i l’últim pel sou brut anual. El valor del sou net menual es calcularà a partir del brut i es desarà també en un vector. El programa ha de demanar per teclat les dades de 5 empleats, i al finalitzar mostrarà els valors per pantalla de la següent forma: &gt;&gt; empleat: 39284019x antiguitat (dies): 784 brut anual (€): 36874.78 net mensual (€): 1659.36 &gt;&gt; empleat: 31214557m antiguitat (dies): 128 brut anual (€): 20015.30 net mensual (€): 1086.54 El sou net mensual es calcula aplicant la següent retenció, i posteriorment dividint per 14 pagues: sou brut retenció sou &lt;12450.0€ 19.0% 12450.0€ &lt;= sou &lt; 20200.0€ 24.0% 20200.0€ &lt;= sou &lt; 35200.0€ 30.0% 35200.0€ &lt;= sou &lt; 60000.0€ 37.0% sou &gt; 60000.0€ 45.0% L’algorisme podria ser el següent: const MAX_ELEMS: integer = 5; TRAM1: float = 12450.0; RETENCIO1: float = 19.0; TRAM2: float = 20200.0; RETENCIO2: float = 24.0; TRAM3: float = 35200.0; RETENCIO3: float = 30.0; TRAM4: float = 60000.0; RETENCIO4: float = 37.0; RETENCIO5: float = 45.0; NUM_PAGUES: integer = 14; end const algorithm vectorsDeVehicles var vDni: vector[MAX_ELEMS] of string; vAntiguitat: vector[MAX_ELEMS] of integer; vBrutAnual: vector[MAX_ELEMS] of real; vNetMensual: vector[MAX_ELEMS] of real; i: integer; end var { La lectura de dades des del canal d&#39;entrada } { S&#39;utilitza un únic índex, i, per recórrer tots els vectors } for i := 1 to MAX_ELEMS do writeString(&quot;dades empleat num. &quot;); writeInteger(i); writeString(&quot;:&quot;); writeString(&quot;&gt;&gt; dni : &quot;); vDni[i] := readString(); writeString(&quot;&gt;&gt; antiguitat : &quot;); vAntiguitat[i] := readInteger(); writeString(&quot;&gt;&gt; brut anual : &quot;); vBrutAnual[i] := readReal(); { Càlcul del sou net mensual } if (vBrutAnual[i] &lt; TRAM1) then vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO1/100)) / NUM_PAGUES; else if (vBrutAnual[i] &lt; TRAM2) then vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO2/100)) / NUM_PAGUES; else if (vBrutAnual[i] &lt; TRAM3) then vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO3/100)) / NUM_PAGUES; else if (vBrutAnual[i] &lt; TRAM4) then vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO4/100)) / NUM_PAGUES; else vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO5/100)) / NUM_PAGUES; end if end if end if end if end for { Es mostren les dades pel canal de sortida } { S&#39;utilitza un únic índex, i, per recórrer tots els vectors } for i := 1 to MAX_ELEMS do writeString(&quot;&gt;&gt; empleat: &quot;); writeString(vDni[i]); writeString(&quot; antiguitat (dies): &quot;); writeInteger(vAntiguitat[i]); writeString(&quot; brut anual (€): &quot;); writeInteger(vBrutAnual[i]); writeString(&quot; net mensual (€): &quot;); writeInteger(vNetMensual[i]); end for end algorithm Com ho podem implementar en C? Una possible solució seria la següent: #include &lt;stdio.h&gt; #define MAX_ELEMS 5 #define TRAM1 12450.0 #define RETENCIO1 19.0 #define TRAM2 20200.0 #define RETENCIO2 24.0 #define TRAM3 35200.0 #define RETENCIO3 30.0 #define TRAM4 60000.0 #define RETENCIO4 37.0 #define RETENCIO5 45.0 #define NUM_PAGUES 14 #define MAX_DNI 9+1 typedef char tDni[MAX_DNI]; int main(int argc, char **argv) { tDni vDni[MAX_ELEMS]; int vAntiguitat[MAX_ELEMS]; float vBrutAnual[MAX_ELEMS]; float vNetMensual[MAX_ELEMS]; int i; /* La lectura de dades des del canal d&#39;entrada. S&#39;utilitza un únic índex, i, per recórrer tots els vectors */ for (i = 0; i &lt; MAX_ELEMS; i++) { printf(&quot;dades empleat num. %d : \\n&quot;, i); printf(&quot;&gt;&gt; dni : &quot;); scanf(&quot;%s&quot;, vDni[i]); printf(&quot;&gt;&gt; antiguitat : &quot;); scanf(&quot;%d&quot;, &amp;vAntiguitat[i]); printf(&quot;&gt;&gt; brut anual : &quot;); scanf(&quot;%f&quot;, &amp;vBrutAnual[i]); /* Càlcul del sou net mensual */ if (vBrutAnual[i] &lt; TRAM1) { vNetMensual[i] = (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO1/100)) / NUM_PAGUES; } else { if (vBrutAnual[i] &lt; TRAM2) { vNetMensual[i] = (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO2/100)) / NUM_PAGUES; } else { if (vBrutAnual[i] &lt; TRAM3) { vNetMensual[i] = (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO3/100)) / NUM_PAGUES; } else { if (vBrutAnual[i] &lt; TRAM4) { vNetMensual[i] = (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO4/100)) / NUM_PAGUES; } else { vNetMensual[i] = (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO5/100)) / NUM_PAGUES; } } } } } /* Es mostren les dades pel canal de sortida. S&#39;utilitza un únic índex, i, per recórrer tots els vectors */ for (i = 0; i &lt; MAX_ELEMS; i++) { printf(&quot;\\n&gt;&gt; empleat: %s \\n&quot;, vDni[i]); printf(&quot; antiguitat (dies): %d \\n&quot;, vAntiguitat[i]); printf(&quot; brut anual (€): %.2f \\n&quot;, vBrutAnual[i]); printf(&quot; net mensual (€): %.2f \\n&quot;, vNetMensual[i]); } return 0; } Dins del bucle utilitzem la variable i com a índex per anar recorrent tots els vectors alhora. En els dos casos la inserció dels valors en els vectors la fem de la mateixa forma: utilitzem l’índex i per determinar la posició del vector on ubicarem els valors: /* ... */ scanf(&quot;%s&quot;, vDni[i]); /* ... */ scanf(&quot;%d&quot;, &amp;vAntiguitat[i]); /* ... */ scanf(&quot;%f&quot;, &amp;vBrutAnual[i]); Al final de l’exemple mostrem tots els empleats introduïts mitjançant un segon bucle, mostrant totes les dades introduïdes anteriorment i les calculades. 4.4 Definició chars vs strings En el llenguatge C, els caràcters es defineixen sempre amb cometa simple ', mentre que pels string s’utilitza la cometa doble &quot;. Exemple: #include &lt;stdio.h&gt; int main(int argc, char **argv) { /* Assignació de valor a un string amb cometa doble */ char salutacio[]= &quot;Hi World&quot;; /* Assignació de valor a un char amb cometa simple */ char exclamacio = &#39;!&#39;; printf(&quot;%s %c\\n&quot;, salutacio, exclamacio); return 0; } "],
["pac05.html", " 5 PAC05 5.1 Comanda strcmp() 5.2 Exemple: comparacioStrings 5.3 Exemple: nòmines 5.4 Comanda scanf 5.5 El finalitzador ‘\\0’ i strcmp() 5.6 El finalitzador ‘\\0’ i strlen()", " 5 PAC05 5.1 Comanda strcmp() En què es basa strcmp() per decidir que, per exemple, la lletra ‘O’ és més gran que la lletra ‘A’? La resposta la tenim en el codi ASCII (numèric) que té associat cada caràcter. Per aquest motiu és normal que interpreti diferent una ‘A’ i una ‘a’, ja que són caràcters diferents; de fet segons els valors ASCII, tenim que ‘A’ &lt; ‘a’. Per si volem consultar la taula ASCII per internet, la podem generar nosaltres mateixos de la següent forma: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int i = 0; /* Relació de caràcters ASCII (només és un subconjunt!) ordenats de més petit a més gran */ for (i=33; i&lt;=126; i++) { printf(&quot;%d : %c\\n&quot;, i, i); } } 5.2 Exemple: comparacioStrings La forma com comparem strings amb llenguatge algorísmic és diferent que no en llenguatge C: Llenguatge algorísmic: la comparació entre strings es fa amb =. Llenguatge C: la comparació entre strings es fa amb la funció strcmp, la qual realitza una comparació caràcter a caràcter de les dues cadenes i com a resultat: Retorna 0: si les dues cadenes són iguals. Retorna -1: si la primera cadena &lt; segona cadena. Retorna 1: si la primera cadena &gt; segona cadena. Un exemple on realitza una comparació de dos strings pot ser el següent: algorithm comparacioStrings var cadena1: string; cadena2: string; end var cadena1:= &quot;UOC&quot;; cadena2:= &quot;UAB&quot;; if (cadena1 = cadena2) then writeString(cadena1); writeString(&quot; = &quot;); writeString(cadena2); else if (cadena1 &gt; cadena2) then writeString(cadena1); writeString(&quot; &gt; &quot;); writeString(cadena2); else writeString(cadena1); writeString(&quot; &lt; &quot;); writeString(cadena2); end if end if end algorithm En llenguatge C, la comparació caràcter a caràcter entre els string “UOC” i “UAB” que realitza la funció strcmp és la següent: Caràcters de la posició 0 dels dos string: UOC vs UAB. Són iguals, amb el que passa a comparar el següent caràcter. Caràcters de la posició 1 dels dos string: UOC vs UAB. Són diferents (‘O’ &gt; ‘A’), finalitza la comparació i la funció strcmp retorna el valor 1. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_STRING 3+1 int main(int argc, char **argv) { char cadena1[MAX_STRING] = &quot;UOC&quot;; char cadena2[MAX_STRING] = &quot;UAB&quot;; int resultatComparacio = 0; resultatComparacio = strcmp(cadena1, cadena2); printf(&quot;Comparació strings \\&quot;%s\\&quot; i \\&quot;%s\\&quot; = %d\\n&quot;, cadena1, cadena2, resultatComparacio); if (resultatComparacio == 0) { printf(&quot;El resultat %d significa que l&#39;string \\&quot;%s\\&quot; == string \\&quot;%s\\&quot;\\n&quot;, resultatComparacio, cadena1, cadena2); } else if (resultatComparacio == -1) { printf(&quot;El resultat %d significa que l&#39;string \\&quot;%s\\&quot; &lt; string \\&quot;%s\\&quot;\\n&quot;, resultatComparacio, cadena1, cadena2); } else if (resultatComparacio == 1) { printf(&quot;El resultat %d significa que l&#39;string \\&quot;%s\\&quot; &gt; string \\&quot;%s\\&quot;\\n&quot;, resultatComparacio, cadena1, cadena2); } return 0; } El resultat de l’execució del programa en C és: Comparació strings &quot;UOC&quot; i &quot;UAB&quot; = 1 El resultat 1 significa que l&#39;string &quot;UOC&quot; &gt; string &quot;UAB&quot; 5.3 Exemple: nòmines Imaginem que volem un programa que ens permeti entrar les nòmines de tots els empleats de la nostra empresa. Un empleat el definim com a nom (cadena de caràcters) + nòmina (real). El programa ha de mostrar al final de tot la relació de nòmines de tots els empleats, la mitjana de totes les nòmines de l’empresa, i qui cobra més i menys a l’empresa. Una possible forma de programa-ho seria la següent: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_EMPLEATS 5 #define MAX_NOM 20+1 typedef struct { char nom[MAX_NOM]; float nomina; } tEmpleat; int main(int argc, char **argv) { tEmpleat vEmpleats[MAX_EMPLEATS]; int i = 0; int maxNomina = 0; int minNomina = 0; float sumaNomines = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { printf(&quot;\\nNom empleat : &quot;); scanf(&quot;%s&quot;, vEmpleats[i].nom); printf(&quot;Nòmina : &quot;); scanf(&quot;%f&quot;, &amp;vEmpleats[i].nomina); } printf(&quot;\\nLlistat de nòmines d&#39;empleats : \\n\\n&quot;); for (i=0; i&lt;MAX_EMPLEATS; i++) { sumaNomines = sumaNomines + vEmpleats[i].nomina; if (vEmpleats[i].nomina &gt; vEmpleats[maxNomina].nomina) { maxNomina = i; } if (vEmpleats[i].nomina &lt; vEmpleats[minNomina].nomina) { minNomina = i; } printf(&quot;%s --&gt; %.2f €\\n&quot;, vEmpleats[i].nom, vEmpleats[i].nomina); } printf(&quot;\\nMitjana nònimes : %.2f €&quot;, sumaNomines/MAX_EMPLEATS); printf(&quot;\\nNòmina més alta : %.2f € (%s)&quot;, vEmpleats[maxNomina].nomina, vEmpleats[maxNomina].nom); printf(&quot;\\nNòmina més baixa : %.2f € (%s)&quot;, vEmpleats[minNomina].nomina, vEmpleats[minNomina].nom); } Com es pot veure, s’utilitza un vector de tEmpleat de forma que donada una longitud màxima del vector, anirem introduint els tEmpleats un a un dins d’ell. Una vegada fet, ja podem tornar a recórrer el vector de tEmpleat i realitzar tots els càlculs que ens demanen, així com mostrar per pantalla les nòmines de tots els empleats. En aquest exemple la variable i fa d’índex per recórrer el vector, i les variables maxNomina i minNomina també són índexos: indiquen en quina posició estàn els empleats amb la nòmina més alta i més baixa respectivament. 5.4 Comanda scanf Quan utilitzem la comanda scanf fins ara sempre li hem passat el nom de la variable precedit per&amp;. Això significa que realment a aquesta comanda li estem passant la posició de la memòria on resideix la variable que li indiquem. Així, per exemple, quan fem la següent operació scanf(&quot;%d&quot;, &amp;numero); estem passant el valor que introduïm per teclat directament a la posició de memòria on tenim desada la variable numero. D’aquí ve utilitzar &amp;numero en comptes de numero. El mateix comportament tenim pels tipus primitius char, float, etc. Els vectors de caràcters en llenguatge C tenen una característica: el nom de l’array conté l’adreça de memòria on està desada la primera posició de l’array. Per exemple, quan executem scanf(&quot;%s&quot;, cadena); el valor de cadena és l’adreça de memòria inicial on està ubicat l’array. Dit d’una altra manera, cadena conté el mateix valor que &amp;cadena[0] (és una altra forma que tenim per referir-nos a la posició inicial en memòria de l’array). Adjunto un exemple amb tots aquests conceptes: #include &lt;stdio.h&gt; #define MAXIM 10 int main(int argc, char **argv) { char cadena[MAXIM]; int numero; printf(&quot;Reservada la posició de memòria %p per la variable numero\\n&quot;, &amp;numero); printf(&quot;Reservada la posició de memòria %p per la variable cadena\\n&quot;, cadena); printf(&quot;Reservada la posició de memòria %p per la variable cadena\\n&quot;, &amp;cadena[0]); printf(&quot;\\nIntrodueix un número enter: &quot;); scanf(&quot;%d&quot;, &amp;numero); printf(&quot;\\nIntrodueix una cadena: &quot;); scanf(&quot;%s&quot;,cadena); printf(&quot;\\nHas assignat els següents valors :\\n&quot;); printf(&quot;numero = %d \\n&quot;, numero); printf(&quot;cadena = %s \\n&quot;, cadena); return 0; } 5.5 El finalitzador ‘\\0’ i strcmp() Com es va veure al mòdul Cadenes de caràcters en C de la xWiki, “una cadena de caràcters o string és una seqüència de caràcters finalitzada pel caràcter ‘\\0’”. Per tant hem de tenir en compte que el finalitzador ‘\\0’ càpiga a la nostra variable, ja que aquesta és la forma que té C de saber on s’acaba un string en memòria. Imaginem que tenim tres cadenes, amb el mateix contingut però de mida diferent (podem tenir posicions buides). Què passa si les comparem? I si comparem amb una cadena de mateix contingut però sense finalitzador ‘\\0’? #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char ciutat1[7] = &quot;Girona&quot;; char ciutat2[8] = &quot;Girona&quot;; char ciutat3[6] = &quot;Girona&quot;; /* no conté el &#39;\\0&#39; final */ /* si strcmp retorna 0 significa que les dues cadenes són iguals */ printf (&quot;Les variables ciutat1 i ciutat2 són iguals? %d\\n&quot;, strcmp(ciutat1, ciutat2)); printf (&quot;Les variables ciutat1 i ciutat3 són iguals? %d\\n&quot;, strcmp(ciutat1, ciutat3)); } La forma que tenim per forçar que una cadena no contingui el finalitzador és limitant la seva mida als caràcters que contindrà, sense tenir en compte reservar-ne un pel ‘\\0’. En aquest cas ho fem amb char ciutat3[6] = &quot;Girona&quot;. La sortida generada és la següent: Les variables ciutat1 i ciutat2 són iguals? 0 Les variables ciutat1 i ciutat3 són iguals? -1 D’aquí la importància del finalitzador de cadenes de caràcters. Per tant, si per exemple ens diuen que tindrem una variable x de tipus string i de mida màxima 15, realment al nostre programa la definirem amb longitud 15+1, per tal que hi càpiga el finalitzador ‘\\0’ en cas que s’ocupin els 15 caràcters anteriors. 5.6 El finalitzador ‘\\0’ i strlen() A continuació s’exposa un exemple en el qual es mostra la importància del finalitzador ‘\\0’ en la funció strlen() de C, la qual ens retorna la mida d’una cadena de caràcters : #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_LLETRES 8+1 int main(int argc, char **argv) { char nom[MAX_LLETRES]; int numLletres; printf(&quot;Introdueix un nom: &quot;); scanf(&quot;%s&quot;, nom); /* Exemple: si en aquest punt hem teclejat el * nom Quim, dins de la cadena de caracters nom * tindrem les següents dades: * * nom[0] = &#39;Q&#39; * nom[1] = &#39;u&#39; * nom[2] = &#39;i&#39; * nom[3] = &#39;m&#39; * nom[4] = &#39;\\0&#39; (finalitzador de l&#39;string) * nom[5] = valor aleatori * nom[6] = valor aleatori * nom[7] = valor aleatori * nom[8] = valor aleatori * * El finalitzador &#39;\\0&#39; s&#39;afegeix automàticament * en llegir un string per teclat amb scanf. * * La comanda strlen(...) va recorrent l&#39;string posició * a posició per saber la seva longitud. Quan finalitza * aquest recorregut? hi ha dues opcions possibles: * * - quan troba el finalitzador &#39;\\0&#39; * - quan arriba a la darrera posició de l&#39;string * * Per tant, si com a nom hem entrat Quim, el valor que * retornarà strlen(...) serà 4. */ numLletres = strlen(nom); printf(&quot;El nom \\&quot;%s\\&quot; té %d lletres.\\n&quot;, nom, numLletres); /* Què passa si sobreescrivim el finalitzador &#39;\\0&#39; amb * un caràcter qualsevol? per exemple &#39;X&#39; */ printf(&quot;\\nSobreescrivim el finalitzador &#39;\\\\0&#39;.&quot;); nom[numLletres] = &#39;X&#39;; /* Tornem a calcular la longitud de l&#39;string */ numLletres = strlen(nom); /* Per quin motiu ara ha canviat la longitud de la * variable nom, si no l&#39;hem tornat a redefinir? */ printf(&quot;\\nAra el nom \\&quot;%s\\&quot; té %d lletres.\\n&quot;, nom, numLletres); return 0; } Si s’executa el programa, la sortida obtinguda serà similar a la següent: Introdueix un nom: Quim El nom &quot;Quim&quot; té 4 lletres. Sobreescrivim el finalitzador &#39;\\0&#39;. Ara el nom &quot;QuimX�!��&quot; té 9 lletres. "],
["pac06.html", " 6 PAC06 6.1 Diferències entre funcions i accions 6.2 Exemple: ús d’accions 6.3 Exemple: ús de funcions 6.4 Exemple: nòmines 6.5 Exemple: pivotDefensiu", " 6 PAC06 6.1 Diferències entre funcions i accions A continuació explicaré les diferències entre una funció i una acció, quins tipus de paràmetres utilitzen, com s’implementen en llenguatge C, i finalment què passa quan un paràmetre és una tupla. És important que es vagin consolidant tots aquests conceptes. Les principals diferències són: Funcions Accions Retornen un valor? sí no Tipus de paràmetres entrada (in) entrada (in), sortida (out), entrada/sortida (inout) El retorn de valor de les funcions permet que aquest es pugui assignar a una variable, cosa que no es pot fer amb les accions. Per exemple, imaginem que volem implementar en llenguatge C la funció suma(); una possible implementació podria ser: #include &lt;stdio.h&gt; /* Predeclaració de la funció */ int suma(int n1, int n2); int main(int argc, char **argv) { int num1 = 3; int num2 = 2; int resultat = 0; printf(&quot;Valor de num1 = %d\\n&quot;, num1); printf(&quot;Valor de num2 = %d\\n&quot;, num2); printf(&quot;Inici execució funció\\n&quot;); resultat = suma(num1, num2); printf(&quot;Resultat suma = %d\\n&quot;, resultat); printf(&quot;Fi execució funció\\n&quot;); return 0; } /* Implementació de la funció */ int suma(int n1, int n2) { return (n1+n2); } L’execució generarà la següent sortida: Valor de n1 = 3 Valor de n2 = 3 Inici execució funció suma: 3 + 2 = 5 Fi execució funció Com es pot veure, el valor de retorn de la funció suma() l’assignem a la variable resultat. En una funció, els paràmetres passats sempre seran d’entrada (in): això significa que dins de la funció únicament seran valors de consulta, no els modificarem per res. Per entendre bé com s’implementa una acció, relacionaré exemples similars amb els diferents tipus de paràmetres que pot tenir una acció: entrada, sortida i entrada/sortida. 6.1.1 Paràmetres d’entrada (in) Són aquells paràmetres que es passen a una acció i dels quals únicament utilitzarem el seu contingut. Això significa que treballarem amb ells en mode lectura: obtindrem els seus valors per tal de realitzar càlculs, però mai modificarem el seu contingut. Exemple: #include &lt;stdio.h&gt; /* Predeclaració de l&#39;acció */ void suma(int num1, int num2); int main(int argc, char **argv) { int n1 = 3; int n2 = 2; printf(&quot;Valor de n1 = %d\\n&quot;, n1); printf(&quot;Valor de n2 = %d\\n&quot;, n1); printf(&quot;Inici execució funció\\n&quot;); suma(n1, n2); printf(&quot;Fi execució funció\\n&quot;); printf(&quot;Valor de n1 = %d\\n&quot;, n1); printf(&quot;Valor de n2 = %d\\n&quot;, n1); return 0; } /* Implementació de l&#39;acció */ void suma(int num1, int num2) { int resultat = num1 + num2; printf(&quot;suma2: %d + %d = %d\\n&quot;, num1, num2, resultat); } L’execució generarà la següent sortida: Valor de n1 = 3 Valor de n2 = 3 Inici execució acció suma: 3 + 2 = 5 Fi execució acció Valor de n1 = 3 Valor de n2 = 3 Com es pot observar, ni n1 ni n2 han modificat el seu valor després de l’execució de l’acció: son paràmetres d’entrada. Aquest tipus de paràmetre també es referencia com a paràmetre per valor, o pas per valor, ja que el que estem passant és un valor (no pas un punter). 6.1.2 Paràmetres de sortida (out) A diferencia dels paràmetres d’entrada, els de sortida s’utilitzen únicament per guardar valors. Poden contenir qualsevol valor inicial, que aquest no serà utilitzat dins de l’acció. Una vegada realitzats tots els càlculs de l’acció, el resultat final es guardarà en el paràmetre de sortida. Exemple: #include &lt;stdio.h&gt; /* Predeclaració de l&#39;acció */ void suma(int num1, int num2, int *res); int main(int argc, char **argv) { int n1 = 3; int n2 = 2; int resultat = 0; int *pResultat = &amp;resultat; printf(&quot;Valor de resultat = %d\\n&quot;, resultat); printf(&quot;Inici execució acció\\n&quot;); suma(n1, n2, pResultat); printf(&quot;suma: %d + %d = %d\\n&quot;, n1, n2, resultat); printf(&quot;Fi execució acció\\n&quot;); printf(&quot;Valor de resultat = %d\\n&quot;, resultat); return 0; } /* Implementació de l&#39;acció */ void suma(int num1, int num2, int *res) { *res = num1 + num2; } L’execució generarà la següent sortida: Valor de resultat = 0 Inici execució acció suma: 3 + 2 = 5 Fi execució acció Valor de resultat = 5 De moment ignorarem que es tracta d’un punter: independientement del valor que tingui res al pasar-se per paràmetre, quan finalitzi l’acció contindrà la suma dels altres dos paràmetres d’entrada num1 i num2. El valor resultat ha canviat, de 0 a 5. Es considera un paràmetre de sortida perquè, independientement del valor inicial que tingui aquest, no s’utilitza per res i en finalitzar l’acció contindrà el resultat de l’operació suma(). Ara sí comentem el fet d’utilitzar el punter: la manera que tenim a C per modificar una variable definida fora d’una acció des de dins de la mateixa és treballant precisament amb la seva direcció de memòria. Aquest tipus de paràmetre també es referencia com a paràmetre per referència, o pas per referència, ja que passem un punter. 6.1.3 Paràmetres d’entrada/sortida (inout) Aquest tipus de paràmetre és una suma dels dos comportaments anteriors: d’una banda el seu valor importa a l’hora de realitzar els càlculs de l’acció, i a la vegada en finalitzar l’execució de l’acció tindrà un valor diferent, també significatiu per tractar-se del resultat final del càlcul. #include &lt;stdio.h&gt; /* Predeclaració de l&#39;acció */ void suma(int *pNum1, int num2); int main(int argc, char **argv) { int n1 = 3; int n2 = 2; int *pNum1 = &amp;n1; printf(&quot;Valor de n1 = %d\\n&quot;, n1); printf(&quot;Valor de n2 = %d\\n&quot;, n2); printf(&quot;Inici execució acció\\n&quot;); suma(pNum1, n2); printf(&quot;Resultat suma = %d\\n&quot;, n1); printf(&quot;Fi execució acció\\n&quot;); printf(&quot;Resultat (n1=n1+n2) = %d\\n&quot;, n1); return 0; } /* Implementació de l&#39;acció */ void suma(int *pNum1, int num2) { *pNum1 = *pNum1 + num2; } L’execució generarà la següent sortida: Valor de n1 = 3 Valor de n2 = 2 Inici execució acció Resultat suma = 5 Fi execució acció Resultat (n1=n1+n2) = 5 En aquest cas s’ha realitzat la suma com a n1 = n1 + n2 : el resultat de la suma de les dues variables es guarda a la primera d’elles. Així doncs el valor de la variable n1 importa tant a l’entrada com a la sortida de l’acció, amb el que es tracta d’un paràmetre d’entrada/sortida. Aquest tipus de paràmetre també es referencia com a paràmetre per referència, o pas per referència, ja que passem un punter. 6.1.4 Tuples com a paràmetres Quan un paràmetre d’una acció/funció és una tupla , la forma com accedirem als seus atributs dins de l’acció/funció variarà en funció del tipus de paràmetre: Paràmetres d’entrada: l’accessor als atributs és el . (un punt). Per tant dins de la funció/acció, accedirem als atributs de la tupla passada per paràmetre de la següent forma: nomTupla.nomAtribut. Paràmetres de sortida i d’entrada/sortida: en aquest cas l’accessor als atributs de la tupla és -&gt;. Així, dins de l’acció podrem fer referència als atributs de la tupla passada per paràmetre de la forma: nomTupla-&gt;nomAtribut. 6.2 Exemple: ús d’accions Adjunto un exemple inventat de com es poden definir accions que permetin modificar els atributs d’una tupla passada com a punter. He posat comentaris detallats al codi per tal que sigui el més clar possible: #include &lt;stdio.h&gt; #define MAX_CHAR 10+1 typedef struct { char nom[MAX_CHAR]; float nomina; } tEmpleat; /* Predeclaració de les accions */ void printEmpleat(tEmpleat empleat); void setNominaEmpleat(tEmpleat *empleat, float nomina); void setNomEmpleat(tEmpleat *empleat, char nom[MAX_CHAR]); int main(int argc, char* argv[]) { /* Declarem nouEmpleat de tipus tEmpleat, * però no li donarem cap valor directament * als seus dos atributs (nom i nomina): ho * farem mitjançant dues accions */ tEmpleat nouEmpleat; /* Els valors dels atributs nom i nomina els * llegirem des de teclat i els desarem inicialment * en les següents dues variables */ char nom[MAX_CHAR]; float nomina; printf(&quot;\\nNom empleat : &quot;); scanf(&quot;%s&quot;, nom); printf(&quot;Nòmina empleat : &quot;); scanf(&quot;%f&quot;, &amp;nomina); /* Assignem el nom i la nòmina al tEmpleat nouEmpleat * utilitzant les accions definides. Fixeu-vos * que el paràmetre nouEmpleat el passem com a punter * (passem la seva adreça en memòria, ja que va * precedit per &amp;) */ setNomEmpleat(&amp;nouEmpleat, nom); setNominaEmpleat(&amp;nouEmpleat, nomina); /* Mostrem les dades de la tupla tEmpleat nouEmpleat * per pantalla */ printEmpleat(nouEmpleat); return 0; } /* Implementació de les accions */ void printEmpleat(tEmpleat empleat) { /* El paràmetre empleat és d&#39;entrada, amb el * que l&#39;accés als seus atributs ho farem * amb un punt : empleat.nom, empleat.nomina */ printf(&quot;\\nDades de l&#39;empleat: \\n&quot;); printf(&quot;\\tNom: %s\\n&quot;, empleat.nom); printf(&quot;\\tNòmina: %.2f €\\n&quot;, empleat.nomina); } void setNominaEmpleat(tEmpleat *empleat, float nomina) { /* El paràmetre empleat (de tipus inout) és un punter, * per tal que des de dins de l&#39;acció sigui possible * modificar el valor (d&#39;un atribut) de l&#39;empleat * definit al main del nostre programa. * L&#39;accés a un atribut d&#39;un element referenciat amb * un punter es fa amb &#39;-&gt;&#39; : empleat-&gt;nomina. */ empleat-&gt;nomina = nomina; } void setNomEmpleat(tEmpleat *empleat, char nom[MAX_CHAR]) { /* Idem que en l&#39;acció setNominaEmpleat. En aquest cas * a més a més cal recordar que l&#39;assignació d&#39;strings * la fem amb la funció strcpy de C, en comptes * d&#39;utilitzar l&#39;assignació habitual dels tipus * primitius (char, int, float, ...) */ strcpy(empleat-&gt;nom, nom); } 6.3 Exemple: ús de funcions Si el resultat que has de retornar és un string, utilitza una acció amb un paràmetre de sortida en comptes d’una funció. Les funcions fes-les servir únicament per retornar valors no compostos, com vectors o tuples: per exemple enters o decimals. Et poso un exemple inventat perquè vegis com es fa: #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Programa que, donada una hora, indica * a quina part del dia correspon. * Per &quot;part del dia&quot; s&#39;entèn: matinada, * matí, migdia, tarda, vespre i nit. * L&#39;hora s&#39;aconsegueix mitjançant una * funció, la qual retorna un valor * enter en format HHMM (on HH=hora i * MM=minut). * D&#39;altra banda, el càlcul de la part * del dia es realitza amb una acció, * la qual rep dos paràmetres: un d&#39;entrada * corresponent a l&#39;hora en format HHMM, * i un altre de sortida que contindrà * la part del dia (string) que correspon * a l&#39;hora. */ #define MAX_CHARS 8+1 /* Predeclaració de funcions i accions */ void calcularPartDelDia(int hora, char *part); int demanarHora(); /* Programa principal */ int main(int argc, char **argv) { int hora; char partDelDia[MAX_CHARS]; hora = demanarHora(); calcularPartDelDia(hora, partDelDia); printf(&quot;L&#39;hora %d correspon a: %s \\n&quot;, hora, partDelDia); return 0; } /* Implementació de funcions i accions */ /* Funció que retorna un enter, corresponent * a l&#39;hora introduïda per teclat, en format * HHMM */ int demanarHora() { int hora; printf(&quot;Tecleja hora (format HHMM) : &quot;); scanf(&quot;%d&quot;, &amp;hora); return hora; } /* Acció que, donada una hora (paràmetre * d&#39;entrada), calcula quina part del dia * correspon (paràmetre de sortida). La * part del dia és de tipus string. El * paràmetre de sortida ha de ser un * punter, per tal que des de dins de * l&#39;acció es pugui modificar el valor * de la variable definida fora de * l&#39;acció, dins del main. */ void calcularPartDelDia(int hora, char *part) { /* Particionat horari extret de * http://esadir.cat/entrades/fitxa/id/5142 */ /* 0000 correspon a 0 */ if ((hora &gt; 2200 &amp;&amp; hora &lt;= 2350) || hora == 0) { strcpy(part, &quot;nit&quot;); } else { /* 0000 correspon a 0 */ /* 0500 correspon a 500 */ if (hora &gt; 0 &amp;&amp; hora &lt;= 500) { strcpy(part, &quot;matinada&quot;); } else { /* 0500 correspon a 500 */ if (hora &gt; 500 &amp;&amp; hora &lt;= 1100) { strcpy(part, &quot;mati&quot;); } else { if (hora &gt; 1100 &amp;&amp; hora &lt;= 1400) { strcpy(part, &quot;migdia&quot;); } else { if (hora &gt; 1400 &amp;&amp; hora &lt;= 1900) { strcpy(part, &quot;tarda&quot;); } else { if (hora &gt; 1900 &amp;&amp; hora &lt;= 2200) { strcpy(part, &quot;vespre&quot;); } else { strcpy(part, &quot;unknown!&quot;); } } } } } } } Un exemple d’execució: Tecleja hora (format HHMM) : 1614 L&#39;hora 1614 correspon a: tarda 6.4 Exemple: nòmines Imaginem que treballem amb els empleats d’una empresa. Posem per cas que després d’introduir n-empleats al nostre sistema, volem una funció que ens retorni l’empleat que té la nòmina més petita. Com que esperem un valor de retorn, estem davant d’una funció. A la funció li passarem un vector d’empleats amb tots els empleats que prèviament hem introduit a la nostra empresa. Sense entrar en la codificació de la funció, el main del nostre programa pot ser similar al següent: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_EMPLEATS 2 #define MAX_CARACTERS 20+1 typedef struct { char nom[MAX_CARACTERS]; char cognom[MAX_CARACTERS]; float nomina; } tEmpleat; int main(int argc, char **argv) { tEmpleat vEmpleats[MAX_EMPLEATS]; int i = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { printf(&quot;\\nNom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].nom); printf(&quot;Cognom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].cognom); printf(&quot;Nòmina empleat %d : &quot;, i); scanf(&quot;%f&quot;, &amp;vEmpleats[i].nomina); } tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats); printf(&quot;\\nL&#39;empleat amb la nòmina més baixa és %s, %s (%.2f €)&quot;, empleat.cognom, empleat.nom, empleat.nomina); return 0; } Fins aquest punt no hi ha res nou: utilitzem en aquest cas un vector de tEmpleat per tal d’anar introduint els empleats per teclat, i per cada empleat demanem el nom, el cognom i la seva nòmina. El que cal fer ara és implementar la funció cercaEmpleatNominaMinima, que rep com a paràmetre el vector d’empleats de l’empresa. De moment oblidem-nos que estem davant d’una funció, simplement centrem-nos en quina és l’acció que volem fer. En aquest cas, volem fer un programa que recorri un a un tots els elements d’un vector, i trobi l’empleat que cobra menys. Una possible codificació seria la següent: int i = 0; int minNomina = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { if (vector[i].nomina &lt; vector[minNomina].nomina) { minNomina = i; } } Aquest fragment de codi simplement recorre un a un tots els tEmpleat d’un vector, comparant la nòmina més baixa trobada fins el moment amb la de l’empleat que està tractant en qüestió, i si aquesta segona és més baixa, ens quedem amb la seva posició dins del vector com a empleat amb la nòmina més baixa (és el mateix plantejament que l’exposat a l’exemple de la setmana passada, per tant fins aquí res nou). Ara convertim aquest fragment de codi en una funció: tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX_EMPLEATS]) { int i = 0; int minNomina = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { if (vector[i].nomina &lt; vector[minNomina].nomina) { minNomina = i; } } return vector[minNomina]; } Com es pot veure, l’única diferència és que ara el codi té la capçalera de la funció, la qual ens diu que rep com a paràmetre un element de tipus vector de tEmpleat, i que retornarà un element de tipus tEmpleat. D’aquesta forma el programa complet queda de la següent manera: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_EMPLEATS 2 #define MAX_CARACTERS 20+1 typedef struct { char nom[MAX_CARACTERS]; char cognom[MAX_CARACTERS]; float nomina; } tEmpleat; /* Predeclaració de funcions/accions */ tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX_EMPLEATS]); int main(int argc, char **argv) { tEmpleat vEmpleats[MAX_EMPLEATS]; int i = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { printf(&quot;\\nNom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].nom); printf(&quot;Cognom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].cognom); printf(&quot;Nòmina empleat %d : &quot;, i); scanf(&quot;%f&quot;, &amp;vEmpleats[i].nomina); } tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats); printf(&quot;\\nL&#39;empleat amb la nòmina més baixa és %s, %s (%.2f €)&quot;, empleat.cognom, empleat.nom, empleat.nomina); return 0; } /* Implementació de funcions/accions */ tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX_EMPLEATS]) { int i = 0; int minNomina = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { if (vector[i].nomina &lt; vector[minNomina].nomina) { minNomina = i; } } return vector[minNomina]; } Aquest exemple pot semblar senzill perquè el tipus de comparació que estem fent és numèrica: comparem dos camps de tipus float (les nòmines de dos empleats). Ampliem ara la funcionalitat del nostre programa: volem que pugui fer una cerca per cognom entre els nostres empleats. Per fer aquesta cerca, caldrà comparar una cadena de caràcters amb el cognom de cada empleat. Per no fer la funció més complexa del necessari, imaginarem que cap cognom es pot repetir i que sempre trobarem un cognom com el que busquem (l’objectiu és veure com funciona strcmp). Així doncs la nostra funció rebrà un vector d’empleats i un cognom a cercar, i retornarà l’empleat amb aquell cognom. Poso tot el codi complet, comentant la part de l’strcmp() detalladament (remarco en blau la comparació) : #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_EMPLEATS 2 #define MAX_CARACTERS 20+1 typedef struct { char nom[MAX_CARACTERS]; char cognom[MAX_CARACTERS]; float nomina; } tEmpleat; /* Predeclaració de funcions/accions */ tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX_EMPLEATS]); tEmpleat cercaEmpleatPerCognom(tEmpleat vector[MAX_EMPLEATS], char cognom[MAX_CARACTERS]); int main(int argc, char **argv) { tEmpleat vEmpleats[MAX_EMPLEATS]; char cognom[MAX_CARACTERS]; int i = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { printf(&quot;\\nNom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].nom); printf(&quot;Cognom empleat %d : &quot;, i); scanf(&quot;%s&quot;, vEmpleats[i].cognom); printf(&quot;Nòmina empleat %d : &quot;, i); scanf(&quot;%f&quot;, &amp;vEmpleats[i].nomina); } tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats); printf(&quot;\\nL&#39;empleat amb la nòmina més baixa és %s, %s (%.2f €)&quot;, empleat.cognom, empleat.nom, empleat.nomina); printf(&quot;Cognom de l&#39;empleat a cercar : &quot;); scanf(&quot;%s&quot;, cognom); tEmpleat empleatCognom = cercaEmpleatPerCognom(vEmpleats, cognom); printf(&quot;Dades de l&#39;empleat: %s, %s -&gt; %f&quot;, empleatCognom.cognom, empleatCognom.nom, empleatCognom.nomina); return 0; } /* Implementació de funcions/accions */ tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX_EMPLEATS]) { int i = 0; int minNomina = 0; for (i=0; i&lt;MAX_EMPLEATS; i++) { if (vector[i].nomina &lt; vector[minNomina].nomina) { minNomina = i; } } return vector[minNomina]; } tEmpleat cercaEmpleatPerCognom(tEmpleat vector[MAX_EMPLEATS], char cognom[MAX_CARACTERS]) { int i = 0; tEmpleat empleat; for (i=0; i&lt;MAX_EMPLEATS; i++) { /* Per comparar strings utilitzarem la funció * strcmp de C. Aquesta funció compara dues * cadenes de caràcters, i retorna un valor * com a resultat de la comparació: * - si el valor és 0: les dues cadenes són iguals * - si el valor és -1: la primera cadena &lt; segona cadena * - si el valor és 1: la primera cadena &gt; segona cadena * En el nostre cas ens interessa detectar que * els cognoms siguin iguals, amb el que * volem controlar que el valor que retorna * la funció strcmp sigui 0. */ if (strcmp(vector[i].cognom, cognom) == 0) { return vector[i]; } } } 6.5 Exemple: pivotDefensiu #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Rebem una petició d&#39;un equip femení de bàsquet, * en el qual ens demanen un programa que els permeti * seleccionar la millor pivot defensiu d&#39;entre una * sèrie de candidates. * La millor pivot defensiu és aquella que captura * més rebots; en cas d&#39;empat, s&#39;escollirà la que * faci més taps. * Caldrà implementar 3 accions i 1 funció: * - acció llegirJugadora(j): llegeix de teclat i * guarda tots els atributs de la jugadora a la * tupla j. * - acció mostrarJugadora(j): mostra per pantalla * el valor dels atributs de la tupla j. * - acció copiarJugadores(j1, j2): copia el valor * de tots els atributs de j2 cap a j1. * - funció compararJugadores(j1, j2): retorna -1 en * cas que la millor pivot sigui j1, i 1 en cas * que la millor sigui j2. */ #define MAX_NOM 20+1 #define MAX_COGNOM 20+1 #define MAX_JUGADORES 3 typedef struct { char nom[MAX_NOM]; char cognom[MAX_COGNOM]; float rebots; float taps; } tJugadora; /* Predeclaracions */ void llegirJugadora(tJugadora *j); void mostrarJugadora(tJugadora j); void copiarJugadora(tJugadora *desti, tJugadora origen); int compararJugadores(tJugadora j1, tJugadora j2); /* Programa principal */ int main(int argc, char **argv) { tJugadora vJugadores[MAX_JUGADORES]; int i, resultat; /* Es crea la tJugadora fictícia * millorPivot que ens ajudarà a trobar * la millor opció d&#39;entre totes les * candidates */ tJugadora millorPivot; millorPivot.rebots = 0; millorPivot.taps = 0; /* Llegim totes les jugadores amb * l&#39;acció llegirJugadora(). Aquesta * acció rep un paràmetre de sortida * (out), el qual contindrà la * jugadora llegit per teclat. Com que * es tracta d&#39;un paràmetre de tipus * out, es realitzarà un pas per * referència (= passarem un punter) */ for (i=0; i&lt;MAX_JUGADORES; i++) { tJugadora jugadora; llegirJugadora(&amp;jugadora); vJugadores[i] = jugadora; } /* Mostrem per pantalla quina * és la millor jugadora amb perfil * pivot defensiu. La idea és anar * recorrent una a una les jugadores * del vector i comparar-les amb millorPivot: * 1. Si la jugadora del vector és millor * que millorPivot, copiarem les dades * de la jugadora cap a millorPivot. * 2. Si millorPivot és millor que la * jugadora del vector, no farem res. * En finalitzar el recorregut de totes * les jugadores del vector, tindrem que * millorPivot contindrà la jugadora * que estem buscant. */ for (i=0; i&lt;MAX_JUGADORES; i++) { resultat = compararJugadores(millorPivot, vJugadores[i]); if (resultat == 1) { copiarJugadora(&amp;millorPivot, vJugadores[i]); } } printf(&quot;\\nMillor opció com a pivot defensiu : &quot;); mostrarJugadora(millorPivot); return 0; } /* Implementació de les accions */ void llegirJugadora(tJugadora *j) { printf(&quot;Introdueix les dades de la nova jugadora: \\n&quot;); printf(&quot;\\tNom: &quot;); scanf(&quot;%s&quot;, j-&gt;nom); printf(&quot;\\tCognom: &quot;); scanf(&quot;%s&quot;, j-&gt;cognom); printf(&quot;\\t&gt;&gt; Promigs per partit:\\n&quot;); printf(&quot;\\tRebots: &quot;); scanf(&quot;%f&quot;, &amp;j-&gt;rebots); printf(&quot;\\tTaps: &quot;); scanf(&quot;%f&quot;, &amp;j-&gt;taps); } void mostrarJugadora(tJugadora j) { printf(&quot;\\n%s, %s: %.1f rebots, %.1f taps \\n&quot;, j.cognom, j.nom, j.rebots, j.taps); } void copiarJugadora(tJugadora *desti, tJugadora origen) { /* Recordem: * - si el paràmetre és un punter, l&#39;accessor * d&#39;atributs serà &#39;-&gt;&#39; * - si el paràmetre és un valor, l&#39;accessor * d&#39;atributs serà &#39;.&#39; */ strcpy(desti-&gt;nom, origen.nom); strcpy(desti-&gt;cognom, origen.cognom); desti-&gt;rebots = origen.rebots; desti-&gt;taps = origen.taps; } int compararJugadores(tJugadora j1, tJugadora j2) { /* Estem buscant una jugadora que * tingui un perfil de pivot defensiu, * amb el que agafarem: * 1. Aquella que tingui més rebots per partit * 2. En cas d&#39;empat de rebots, aquella que * faci més taps per partit */ if (j1.rebots &gt; j2.rebots) { return -1; } else { if (j1.rebots &lt; j2.rebots) { return 1; } else { /* En aquest punt tenim que * j1.rebots == j2.rebots, * amb el que anem a comparar el següent * atribut segons la prioritat definida * del perfil pivot defensiu */ if (j1.taps &gt; j2.taps) { return -1; } else { if (j1.taps &lt; j2.taps) { return 1; } else { return 0; } } } } } Exemple d’execució: Introdueix les dades de la nova jugadora: Nom: Julia Cognom: Sanz &gt;&gt; Promigs per partit: Rebots: 7.9 Taps: 0.9 Introdueix les dades de la nova jugadora: Nom: Nuria Cognom: Gutierrez &gt;&gt; Promigs per partit: Rebots: 7.9 Taps: 1.4 Introdueix les dades de la nova jugadora: Nom: Mireia Cognom: Mateu &gt;&gt; Promigs per partit: Rebots: 6.8 Taps: 2.1 Millor opció com a pivot defensiu : Gutierrez, Nuria: 7.9 rebots, 1.4 taps 6.5.1 Explicació sobre l’acció copiarJugadora() L’acció copiarJugadora(tJugadora *desti, tJugadora origen) de l’exemple rep dos paràmetres: El primer d’ells és desti, un punter a una tupla de tipus tJugadora; una altra forma de dir-ho és que el valor de desti el passem per referència. Aquest paràmetre és de tipus out, ja que no utilitzem per res el valor inicial que té i només ens interessa el valor final que tindrà en executar l’acció. El segon és origen, una tupla que passem per valor. Per tant en aquest cas no estem passant el punter a una tJugadora, sinó directament una tJugadora. Quan tenim un punter a una tupla, accedim a l’element mitjançant l’operador -&gt;. En canvi, si estem tractant una tupla accedirem a un atribut seu amb l’operador . (punt). La codificació de l’acció és: void copiarJugadora(tJugadora *desti, tJugadora origen) { /* Recordem: * - si el paràmetre és un punter, l&#39;accessor * d&#39;atributs serà &#39;-&gt;&#39; * - si el paràmetre és un valor, l&#39;accessor * d&#39;atributs serà &#39;.&#39; */ strcpy(desti-&gt;nom, origen.nom); strcpy(desti-&gt;cognom, origen.cognom); desti-&gt;rebots = origen.rebots; desti-&gt;taps = origen.taps; desti-&gt;tirsLliures = origen.tirsLliures; } No utilitzarem el prefix &amp; davant de la tJugadora origen, de la mateixa forma que no utilitzem l’&amp; quan anem a imprimir per pantalla amb printf() el valor d’una variable: com que estem tractant amb un valor, simplement hi accedim a ell i l’utilitzem. Per tant aquestes accions serien incorrectes: strcpy(desti-&gt;nom, &amp;origen.nom); strcpy(desti-&gt;cognom, &amp;origen.cognom); desti-&gt;rebots = &amp;origen.rebots; desti-&gt;taps = &amp;origen.taps; desti-&gt;tirsLliures = &amp;origen.tirsLliures; Sí que tenim una alternativa possible a l’operador -&gt;, segons s’indica a la xWiki: strcpy((*desti).nom, origen.nom); strcpy((*desti).cognom, origen.cognom); (*desti).rebots = origen.rebots; (*desti).taps = origen.taps; (*desti).tirsLliures = origen.tirsLliures; Per tant aquest darrer bloc de codi es pot substituir a l’exemple i tot continua funcionant correctament, ja que són equivalents. Es pot utilitzar una forma o l’altra, tot i que l’operador -&gt; sembla més fàcil d’entendre visualment. "],
["pac07.html", " 7 PAC07 7.1 Quan utilitzar &amp; dins de funcions/accions 7.2 Exemple: com modular un programa amb CodeLite 7.3 Tipus de paràmetres en accions i funcions 7.4 scanf: acció o funció? 7.5 Pas per valor vs pas per referència 7.6 Exemple: capgirar 7.7 Exemple: funció isParell 7.8 Exemple:", " 7 PAC07 7.1 Quan utilitzar &amp; dins de funcions/accions De vegades quan fem crides a accions dins d’accions, veiem que si passem un paràmetre amb &amp; els resultats no són correctes, però en canvi passant el paràmetre sense l’&amp; tot funciona. I a l’inrevés. Per tal d’aclarir aquests dubtes he inventat el següent exemple: és un programa senzill que treballa amb tipus tPac. Un element tPac conté dos atributs: un nom (cadena de caràcters) i una nota (decimal). El programa realitza la lectura de valors des de teclat amb l’acció pacRead(...), la modificació del nom de la pac amb nomToUpperCase(...), i la seva posterior impressió per pantalla mitjançant pacWrite(...). Amb l’objectiu de deixar-ho tot el més clar possible he posat comentaris extensos dins del programa, explicant en cada situació què es fa i per quin motiu. #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Definició de constants */ #define MAX_NOM 5+1 /* Definició de la tupla tPac */ typedef struct { char nom[MAX_NOM]; float nota; } tPac; /* Predeclaració de funcions i accions */ /* Acció que llegeix per teclat els atributs d&#39;un * tipus tPac i li assigna els valors. En aquest * cas el paràmetre pac és de tipus &#39;out&#39;, donat que * el seu valor abans i després d&#39;executar l&#39;acció * haurà canviat. A més, com que el valor inicial * de pac no ens interessa per res (recordem que * l&#39;objectiu d&#39;aquesta acció és llegir de teclat * i donar valor a pac, per tant sobreescriurem * qualsevol valor previ que tingui), podem * descartar que sigui de tipus &#39;inout&#39;. * Quan un paràmetre és de tipus out/inout, el * passem per referència o, el que és el mateix, * passem un punter a un tipus d&#39;element; com * es pot veure, aquí pac és un punter a un * element de tipus tPac, ja que va precedit per *. * Utilitzem un punter perquè és l&#39;única manera * que tenim de modificar un element definit * fora de l&#39;àmbit de l&#39;acció, des de dins de * la pròpia acció. */ void pacRead(tPac *pac); /* Acció que, donat un tipus tPac, mostra el seu * contingut (nom i nota) per pantalla. Aquí el * paràmetre pac és de tipus &#39;in&#39;: el seu valor * abans i després d&#39;executar l&#39;acció no variarà. * Un paràmetre de tipus &#39;in&#39; el passem per valor: * en aquest cas és un element de tipus tPac. * Com es pot veure, no ha d&#39;anar precedit per *. */ void pacWrite(tPac pac); /* Acció que, donat un tipus tPac, agafa el seu * nom i el passa a majúscules. Per exemple, si * el nom és &quot;pAc01&quot; el modificarà a &quot;PAC01&quot;. * El paràmetre és de tipus &#39;inout&#39;: el seu valor * abans i després d&#39;executar l&#39;acció haurà canviat * i a més a més, el valor inicial que té és * important, ja que el necessitem per calcular el * valor final (&quot;pAc01&quot; --&gt; &quot;PAC01&quot;). En ser un * paràmetre de tipus &#39;inout&#39;, passarem el seu * valor per referència: necessitem que pugui ser * modificat des de dins de l&#39;acció, amb el que * és necessari treballar amb un punter a l&#39;element * pac, d&#39;aquí que vagi precedit amb *. */ void nomToUpperCase(tPac *pac); /* Programa principal */ int main(int argc, char **argv) { /* Definim les variables */ tPac pac1, pac2, pac3; /* Donem valor als atributs de cadascuna * de les 3 PAC. Fixeu-vos que estem passant * punters a elements de tipus tPac: el &amp; * previ indica que agafem la direcció de * memòria on resideix l&#39;element de tipus * tPac. Com que passem punters a memòria, * des de dins de l&#39;acció podrem modificar * el contingut de pac1, pac2 i pac3, tot * i que aquestes tres variables han estat * definides fora de l&#39;àmbit de l&#39;acció. */ pacRead(&amp;pac1); pacRead(&amp;pac2); pacRead(&amp;pac3); /* Mostrem per pantalla els atributs de * cadascuna de les 3 PAC. En aquest cas * el pas de paràmetres es fa per valor: * passem directament els elements de tipus * tPac, ja que aquests no seran modificats * des de dins de l&#39;acció (són de tipus &#39;in&#39;). */ pacWrite(pac1); pacWrite(pac2); pacWrite(pac3); return 0; } /* Implementació de funcions i accions */ void pacRead(tPac *pac) { /* Llegim des de teclat el valor * corresponent al nom de la PAC */ printf(&quot;Introdueix nom : &quot;); scanf(&quot;%s&quot;, pac-&gt;nom); /* Llegim des de teclat el valor * corresponent a la nota de la PAC */ printf(&quot;Introdueix nota: &quot;); scanf(&quot;%f&quot;, &amp;pac-&gt;nota); /* Ara arribem en un punt on, dins d&#39;una * acció, cridem a un altra acció. Hem de * passar com a atribut pac? o bé &amp;pac?. * Davant d&#39;aquest dubte, ens hem de * preguntar quin tipus de valor conté ara * mateix (abans d&#39;executar la següent acció) * el paràmetre pac. Si recordem com està * definida l&#39;acció pacRead(tPac *pac), pac * és un punter a memòria, ja que va precedit * per *. Això significa que en aquest precís * moment pac continua sent un punter. * D&#39;altra banda, si ens fixem amb la definició * de l&#39;acció nomToUpperCase(tPac *pac), veiem * que també espera rebre un punter. Així com * que pac és un punter i nomToUpperCase(...) * espera rebre un punter, simplement li passem * pac com a paràmetre (i no pas &amp;pac!) */ nomToUpperCase(pac); printf(&quot;----------------------\\n&quot;); } void pacWrite(tPac pac) { /* Mostrem per pantalla els valors * dels atributs de la PAC */ printf(&quot;&gt;&gt; %s amb nota %.1f \\n&quot;, pac.nom, pac.nota); } void nomToUpperCase(tPac *pac) { /* Hi ha llibreries que ja implementen els canvis * a majúscules o minúscules. En aquest cas però * hem optat per no utilitzar-ne cap, i implementar-la * nosaltres mateixos, tractant l&#39;string nom de pac * com a un recorregut caràcter a caràcter. */ int i = 0; for (i = 0; pac-&gt;nom[i] != &#39;\\0&#39;; i++) { if (pac-&gt;nom[i] &gt;= &#39;a&#39; &amp;&amp; pac-&gt;nom[i] &lt;= &#39;z&#39;) { pac-&gt;nom[i] = pac-&gt;nom[i] + (&#39;A&#39; - &#39;a&#39;); } } } 7.2 Exemple: com modular un programa amb CodeLite A continuació explicaré detalladament com modular el programa típic HelloWorld d’una forma una mica diferent de com s’explica als vídeos, però que crec que pot ser més entenedora. L’explicació és una mica extensa però prefereixo que quedi clar. 7.2.1 Funcionament per defecte d’un projecte a CodeLite: Quan a CodeLite creem un nou projecte, per exemple Modularitat, amb el típic main.c inicial que conté el programa HelloWorld, tenim la següent distribució d’arxius uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l total 12 -rw-r--r-- 1 uoc uoc 93 nov 17 23:56 main.c -rw-rw-r-- 1 uoc uoc 4274 nov 17 23:56 Modularitat.project Si compilem aquest programa a CodeLite, veiem que ens ha generat una carpeta nova anomenada Debug: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l total 24 drwxrwxr-x 2 uoc uoc 4096 nov 17 23:58 Debug -rw-r--r-- 1 uoc uoc 93 nov 17 23:56 main.c -rw-rw-r-- 1 uoc uoc 3249 nov 17 23:58 Modularitat.mk -rw-rw-r-- 1 uoc uoc 4274 nov 17 23:56 Modularitat.project -rw-rw-r-- 1 uoc uoc 17 nov 17 23:58 Modularitat.txt uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ El contingut de la carpeta Debug és programa executable final juntament amb els arxius objecte intermitjos: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ cd Debug uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/Debug$ ls -l total 24 -rw-rw-r-- 1 uoc uoc 4620 nov 17 23:58 main.c.o -rw-rw-r-- 1 uoc uoc 23 nov 17 23:58 main.c.o.d -rwxrwxr-x 1 uoc uoc 9708 nov 17 23:58 Modularitat uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/Debug$ Si es vol, des d’un terminal de Lubuntu es pot executar el programa resultant Modularitat de la següent forma: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/Debug$ ./Modularitat hello world uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/Debug$ 7.2.2 Executable dins de /bin. Anem ara a modificar CodeLite per tal que l’executable ens el guardi sempre dins de la carpeta ./bin. El primer video comenta com canviar la carpeta on es desa l’arxiu executable resultant de compilar el nostre programa. L’objectiu és que en comptes d’utilitzar la carpeta ./Debug l’arxiu executable es desi dins de la nova carpeta ./bin Atenció: aquest apartat no es demana explícitament a la PAC07 (únicament es parla de les carpetes ./src i ./include), amb el que no cal aplicar-ho a la PAC. Per fer aquest canvi, fem clic botó dret del ratolí sobre el nom del projecte, Modularitat -&gt; Settings… -&gt; General -&gt; Output File: hi posem el valor ./bin/$(ProjectName). Això significa que l’executable es desarà dins de la carpeta ./bin i que el seu nom serà el mateix que el nom del projecte (en el cas que tractem, s’anomenarà Modularitat) A més, sense sortir d’aquesta mateixa pantalla, canviem el valor del Working Directory per : ./bin. Aquest valor és el que té en consideració CodeLite a l’hora de buscar l’executable del projecte, per quan fem el Run. Guardem els canvis i si ara compilem novament el programa, veiem que ha creat la carpeta ./bin dins del nostre projecte: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l total 28 drwxrwxr-x 2 uoc uoc 4096 nov 18 00:11 bin drwxrwxr-x 2 uoc uoc 4096 nov 17 23:58 Debug -rw-r--r-- 1 uoc uoc 93 nov 17 23:56 main.c -rw-rw-r-- 1 uoc uoc 3230 nov 18 00:11 Modularitat.mk -rw-rw-r-- 1 uoc uoc 4350 nov 18 00:10 Modularitat.project -rw-rw-r-- 1 uoc uoc 17 nov 18 00:11 Modularitat.txt uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ Igual que en el cas anterior, si volem podem executar el programa des del propi terminal: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ cd ./bin uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/bin$ ls -l total 12 -rwxrwxr-x 1 uoc uoc 9708 nov 18 00:11 Modularitat uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/bin$ ./Modularitat hello world uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat/bin$ A partir d’aquest moment, sempre que compilem el nostre programa, guardarà l’executable dins de la carpeta ./bin. 7.2.3 Modularització del programa en un arxiu de capçaleres i un de funcions. Centraré ara l’explicació amb l’estructura que es demana a la PAC07 i treballant sobre el mateix exemple Modularitat. El que volem aconseguir és la següent estructura: projecte Modularitat | |-- /include/ | | | \\-- helloWorld.h | \\-- /src/ | |-- helloWorld.c \\-- main.c L’objectiu és dividir (modularitzar) l’arxiu únic main.c que tenim fins ara en tres arxius: helloWorld.h : aquest arxiu contindrà la predeclaració de totes les funcions i accions del nostre programa, així com la definició de tots els tipus necessaris (enumeratius, tuples, etc) i constants que requereixi el nostre programa C. Aquest arxiu l’ubicarem dins de la carpeta ./include del nostre projecte helloWorld.c : dins d’ell s’implementaran totes les accions i funcions del programa. Bàsicament contindrà el codi de tot allò que hem predeclarat a l’arxiu helloWorld.h. main.c : contindrà el codi del programa principal, identificat per la funció main(). El primer pas que podem fer és crear les dues carpetes que necessitarà el nostre projecte modularitzat, src i include : uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ mkdir src uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ mkdir include uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l total 36 drwxrwxr-x 2 uoc uoc 4096 nov 18 00:14 bin drwxrwxr-x 2 uoc uoc 4096 nov 18 00:14 Debug drwxrwxr-x 2 uoc uoc 4096 nov 18 00:18 include -rw-r--r-- 1 uoc uoc 93 nov 17 23:56 main.c -rw-rw-r-- 1 uoc uoc 3230 nov 18 00:14 Modularitat.mk -rw-rw-r-- 1 uoc uoc 4350 nov 18 00:10 Modularitat.project -rw-rw-r-- 1 uoc uoc 17 nov 18 00:14 Modularitat.txt drwxrwxr-x 2 uoc uoc 4096 nov 18 00:18 src uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ El següent pas és transformar el programa HelloWorld típic en un programa modularitzat: per aquest motiu ens cal la definició d’algunes funcions o accions que ens permetin separar un únic arxiu en un de capçaleres (helloWorld.h), un d’implementació de funcions/accions (helloWorld.c) i un principal (main.c). Per tant, l’objectiu és passar del següent programa… : #include &lt;stdio.h&gt; int main(int argc, char **argv) { printf(&quot;hello world\\n&quot;); return 0; } … al següent codi modularitzat: #include &lt;stdio.h&gt; /* Predeclaració de les funcions/accions */ void showHelloMessage(); /* Codi principal */ int main(int argc, char **argv) { showHelloMessage(); return 0; } /* Implementació de les funcions/accions */ void showHelloMessage() { printf(&quot;hello world\\n&quot;); }; Si s’executa el nou codi dins d’un únic main.c, aquest seguirà mostrant correctament el missatge de “hello world”. L’objectiu és acabant-lo dividint en tres blocs: #include &lt;stdio.h&gt; /* Inici contingut de l’arxiu helloWorld.h */ /* Predeclaració de les funcions/accions */ void showHelloMessage(); /* Fi contingut de l’arxiu helloWorld.h */ /* Inici contingut de l’arxiu main.c */ /* Codi principal */ int main(int argc, char **argv) { showHelloMessage(); return 0; } /* Fi contingut de l’arxiu main.c */ /* Inici contingut de l’arxiu helloWorld.c */ /* Implementació de les funcions/accions */ void showHelloMessage() { printf(&quot;hello world\\n&quot;); }; /* Fi contingut de l’arxiu helloWorld.c */ El primer pas que farem serà eliminar des de CodeLite el programa vell; per tant, CodeLite -&gt; projecte Modularitat -&gt; src -&gt; botó dret sobre el nom de l’arxiu main.c -&gt; Remove -&gt; confirmem l’esborrat -&gt; confirmem l’esborrat de l’arxiu main.c del disc. En aquest punt, a CodeLite, dins del projecte Modularitat únicament hi tenim una carpeta virtual anomenada src. Atenció: la carpeta virtual anomenada src del nostre projecte de CodeLite en aquests moments no té cap relació amb la carpeta ./src que hem creat fa un moment. Creem el programa principal main.c fent: CodeLite -&gt; projecte Modularitat -&gt; botó dret sobre carpeta src -&gt; Add New File -&gt; seleccionem el tipus C Source File (.c) -&gt; indiquem com a Name: main.c, i com a Location seleccionem la carpeta ./src que hem creat abans. Anem a crear el segon arxiu, helloWorld.c, exactament de la mateixa forma: CodeLite -&gt; projecte Modularitat -&gt; botó dret sobre carpeta src -&gt; Add New File -&gt; seleccionem el tipus C Source File (.c) -&gt; indiquem com a Name: helloWorld.c, i com a Location seleccionem la carpeta ./src creada anteriorment. Creem ara una carpeta virtual dins del nostre projecte amb CodeLite -&gt; botó dret sobre el projecte Modularitat -&gt; New Virtual Folder -&gt; li posem per nom: include Per finalitzar, creem el tercer arxiu requerit: helloWorld.h. Els passos seran: CodeLite -&gt; projecte Modularitat -&gt; botó dret sobre carpeta include -&gt; Add New File -&gt; seleccionem el tipus Header File (.h) -&gt; indiquem com a Name: helloWorld.h, i com a Location seleccionem la carpeta ./include creada anteriorment. En aquest punt el nostre projecte Modularitat a CodeLite tindrà l’estructura desitjada: projecte Modularitat | |-- /include/ | | | \\-- helloWorld.h | \\-- /src/ | |-- helloWorld.c \\-- main.c Ara només cal donar contingut als 3 arxius buits que hem creat. Comencem per l’arxiu de capçaleres helloWorld.h. L’editem com ho fem habitualment a CodeLite, i li copiem el fragment de codi que hem dit abans que li corresponia: #include &lt;stdio.h&gt; /* Predeclaració de les funcions/accions */ void showHelloMessage(); Editem l’arxiu helloWorld.c i li afegim el codi corresponent: /* Implementació de les funcions/accions */ void showHelloMessage() { printf(&quot;hello world\\n&quot;); }; I per finalitzar editem el contingut de l’arxiu main.c amb el codi comentat anteriorment: /* Codi principal */ int main(int argc, char **argv) { showHelloMessage(); return 0; } En aquest punt tenim el programa modularitzat, però ens falta dues qüestions: Configurar CodeLite per tal que tingui presents on buscar l’arxiu de capçaleres .h quan hi fem referència. Fer que els arxius estiguin enllaçats entre ells: ara mateix són completament independents. Anem pel primer punt: per indicar a CodeLite on trobarà tots els arxius .h d’un programa, només cal fer CodeLite -&gt; clic botó dret sobre Modularitat -&gt; Settings… -&gt; Compiler -&gt; dins de l’opció Include Paths afegir el valor .;./include Pel segon punt: tenim que l’arxiu main.c en aquests moments fa referència a una acció anomenada showHelloMessage(), de la qual no en sabem res. El que ens cal és importar l’arxiu de capçaleres; com que és un arxiu que hem creat nosaltres, l’include va entre cometes dobles: #include &quot;helloWorld.h&quot; /* Codi principal */ int main(int argc, char **argv) { showHelloMessage(); return 0; } El següent pas serà afegir l’include habitual de la llibreria stdio.h dins de l’arxiu helloWorld.c, ja que en ell utilitzem la funció printf (inclosa en aquesta llibreria): #include &lt;stdio.h&gt; /* Implementació de les funcions/accions */ void showHelloMessage() { printf(&quot;hello world\\n&quot;); }; En aquest punt ja podem executar el nostre programa modularitzat correctament. L’estructura resultant i el contingut de cada carpeta és el desitjat: uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l ./bin total 12 -rwxrwxr-x 1 uoc uoc 10172 nov 18 01:09 Modularitat uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l ./include/ total 4 -rw-rw-r-- 1 uoc uoc 70 nov 18 00:54 helloWorld.h uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l ./src total 8 -rw-rw-r-- 1 uoc uoc 122 nov 18 01:09 helloWorld.c -rw-rw-r-- 1 uoc uoc 113 nov 18 01:07 main.c uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ ls -l ./Debug/ total 20 -rw-rw-r-- 1 uoc uoc 4544 nov 18 01:09 src_helloWorld.c.o -rw-rw-r-- 1 uoc uoc 43 nov 18 01:09 src_helloWorld.c.o.d -rw-rw-r-- 1 uoc uoc 2440 nov 18 01:09 src_main.c.o -rw-rw-r-- 1 uoc uoc 75 nov 18 01:09 src_main.c.o.d uoc@fp:~/Documents/codelite/workspaces/Test/Modularitat$ Ni per la realització d’aquest exemple ni per la PAC07 cal crear llibreries pròpies, amb el que aquest punt no el comento: únicament tractarem amb arxius de capçalera .h, arxius d’implementació .c, i l’arxiu corresponent al codi principal main.c. 7.3 Tipus de paràmetres en accions i funcions En les accions els paràmetres poden ser de tipus in, out o inout. Cal especificar-ho en el moment de definir l’acció al nostre algorisme. Exemple: tres formes d’implementar una suma de dos enters amb diferents accions segons els tipus in, out o inout dels paràmetres: action suma1(in num1: integer, in num2: integer) var resultat: integer; end var resultat := num1 + num2; writeString(&quot;Resultat de la suma = &quot;); writeInteger(resultat); end action action suma2(in num1: integer, in num2: integer, out resultat: integer) resultat := num1 + num2; end action action suma3(inout num1: integer, in num2: integer) num1 := num1 + num2; end action A les funcions en canvi tots els paràmetres són d’entrada, amb el que no cal indicar l’in. Exemple: function suma4(num1: integer, num2: integer): integer var resultat: integer; end var resultat := num1 + num2; return resultat; end function 7.4 scanf: acció o funció? El que ens indica la signatura de scanf és que estem davant d’una funció: int scanf(const char *format, type* var1, ...); El segon argument no és de tipus out, ja que el que li passem no és la variable que guardarà el valor llegit, sinó el punter a la variable que guardarà el valor llegit, i aquest punter no varia en cap moment. /* Per exemple, el valor de &amp;numero és 0xbfb86c40 */ scanf(&quot;%d&quot;, &amp;numero) /* una vegada executada la funció scanf, el valor de &amp;numero continua sent 0xbfb86c40 */ La funció scanf com a tal retorna un valor, tot i que nosaltres no l’utilitzem (retorna el número d’elements processats correctament). Dit d’una altra forma: que una funció retorni un valor no ens obliga a recuperar-lo i tractar-lo, tot i que habitualment sí que ho farem. D’altra banda, el fet de definir un paràmetre d’una funció/acció com a const significa que aquest paràmetre dins de l’acció/funció es comportarà com a una constant. Per tant dins de l’àmbit de la funció/acció no es podrà modificar. Aquest fet ens pot interessar o no. Per exemple, imagina que creem la següent funció per sumar dos enters: #include &lt;stdio.h&gt; /* Predeclaració de funcions/acions */ int suma(int numA, int numB); int main(int argc, char **argv) { int a = 10; int b = 13; int resultat = suma(a, b); printf(&quot;Resultat: %d + %d = %d\\n&quot;, a, b, resultat); return 0; } /* Implementació de funcions/accions */ int suma(int numA, int numB) { numA = numA + numB; return (numA); } Dins de l’àmbit de la funció, ens interessa per exemple que el paràmetre numA sigui constant? No, ja que si ho definim d’aquesta forma la compilació ens fallarà: #include &lt;stdio.h&gt; /* Predeclaració de funcions/acions */ int suma(const int numA, int numB); int main(int argc, char **argv) { int a = 10; int b = 13; int resultat = suma(a, b); printf(&quot;Resultat: %d + %d = %d\\n&quot;, a, b, resultat); return 0; } /* Implementació de funcions/accions */ int suma(const int numA, int numB) { numA = numA + numB; return (numA); } L’error que obtindrem en intentar compilar el programa serà “error: assignment of read-only parameter ‘numA’”, ja que dins de la funció suma estem modificant el valor de numA. Molt important: que dins de la funció modifiquem el valor de numA no significa que fora de l’àmbit de la funció el valor de la variable a variï (ho podem comprovar al printf que es fa posteriorment). Per tant l’ús de const en un paràmetre s’hauria de limitar a aquells valors que s’hagin de tractar realment com a constants: per exemple, si passem la constant PI = 3.14159… com a paràmetre, dins de la funció segur que no tenim la necessitat de modificar aquesta constant matemàtica, amb el que en aquest cas és més adient utilitzar const en el paràmetre de la funció. Com a darrer punt, no s’ha de confondre el fet de definir un paràmetre d’una funció com a const, a fer que fora de l’àmbit de la funció el paràmetre corresponent es defineixi com a constant: #include &lt;stdio.h&gt; /* Predeclaració de funcions/acions */ int suma(int numA, int numB); int main(int argc, char **argv) { const int a = 10; int b = 13; int resultat = suma(a, b); printf(&quot;Resultat: %d + %d = %d\\n&quot;, a, b, resultat); return 0; } /* Implementació de funcions/accions */ int suma(int numA, int numB) { numA = numA + numB; return (numA); } En aquest cas quan compilem no obtindrem cap error, ja que la variable a és una constant fora de la funció suma, però el seu valor passat com a paràmetre dins de la funció no és una constant. 7.5 Pas per valor vs pas per referència El clàssic pas per valor correspon als paràmetres de tipus in, en els quals passem la variable/valor. D’altra banda el pas per referència consisteix en passar com a paràmetre de tipus out o inout la direcció de memòria de la variable (punter). 7.6 Exemple: capgirar Imagina que tenim una tupla tParaula la qual té dos camps: cadena : conté l’string amb el valor de la tParaula numeroCaractersCadena : conté el número de caracters de la cadena Implementem l’acció capgirar, la qual fa dues operacions: Capgira el camp cadena de la tParaula; per exemple, si entrem “Fonaments” el resultat serà “stnemanoF”. Calcula el valor de numeroCaractersCadena; si tenim com a cadena “Fonaments”, el valor serà 9. Volem que per teclat es demani el valor pel camp cadena de dues tParaula, i en cadascuna d’aquestes dues tParaula volem aplicar l’acció capgirar. Una possible forma d’implementar-ho tot plegat seria la següent: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; #define MAX_CHAR 20+1 #define MAX_PARAULES 2 typedef struct { char cadena[MAX_CHAR]; int numeroCaractersCadena; } tParaula; /* Predeclaració de l&#39;acció. * Aquesta acció reb un paràmetre inout de tipus tParaula, * el qual capgira el camp cadena, i calcula el valor * corresponent pel camp numeroCaractersCadena */ void capgirar(tParaula *mot); int main(int argc, char **argv) { int i = 0; /* Introduim per teclat un total de MAX_PARAULES */ for (i = 0; i &lt; MAX_PARAULES; i++) { tParaula paraula; printf(&quot;Introdueix una paraula : &quot;); scanf(&quot;%s&quot;, paraula.cadena); capgirar(&amp;paraula); printf(&quot;La paraula capgirada és : %s, de %d lletres.\\n&quot;, paraula.cadena, paraula.numeroCaractersCadena); } } /* Implementació de l&#39;acció */ void capgirar(tParaula *mot) { int i; tParaula motCapgirat; int midaMot = strlen(mot-&gt;cadena); for (i=0; i&lt;midaMot; i++ ) { motCapgirat.cadena[(midaMot-1)-i] = mot-&gt;cadena[i]; } /* Indiquem el finalitzador de l&#39;string */ motCapgirat.cadena[midaMot] =&#39;\\0&#39;; strcpy(mot-&gt;cadena, motCapgirat.cadena); mot-&gt;numeroCaractersCadena = midaMot; } L’acció només rep un paràmetre tParaula, no pas dos. Però com que el que volem és executar-lo per cada tParaula introduida per teclat, repetim la crida dues vegades dins del bucle (una per cada tParaula). 7.7 Exemple: funció isParell Exemple de funció que retorna un booleà: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; /* Predeclaració de la funció isParell, la qual retorna un * booleà que indica si el número passat per paràmetre és * parell (true) o no (false). */ bool isParell(int numero); int main(int argc, char **argv) { int numero; printf(&quot;Tecleja un número : &quot;); scanf(&quot;%d&quot;, &amp;numero); if (!isParell(numero)) { printf(&quot;El número %d és senar.\\n&quot;, numero); } else { printf(&quot;El número %d és parell.\\n&quot;, numero); } } /* Implementació de la funció */ bool isParell(int numero) { if (numero % 2 == 0) { return true; } else { return false; } } 7.8 Exemple: S’afegeix a l’exemple de les jugadores de bàsquet un nou factor de comparació: en cas d’empat de les comparacions anteriors, escollirem la que tingui un millor percentatge de tirs lliures. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; /* Rebem una petició d&#39;un equip femení de bàsquet, * en el qual ens demanen un programa que els permeti * seleccionar la millor pivot defensiu d&#39;entre una * sèrie de candidates. * La millor pivot defensiu és aquella que captura * més rebots; en cas d&#39;empat, s&#39;escollirà la que * faci més taps. En cas d&#39;empat ens interessarà * escollir la que tingui millor percentatge * de tirs lliures. * Caldrà implementar 3 accions i 2 funcions: * - acció llegirJugadora(j): llegeix de teclat i * guarda tots els atributs de la jugadora a la * tupla j. * - acció mostrarJugadora(j): mostra per pantalla * el valor dels atributs de la tupla j. * - acció copiarJugadores(j1, j2): copia el valor * de tots els atributs de j2 cap a j1. * - funció compararJugadores(j1, j2): retorna -1 en * cas que la millor pivot sigui j1, i 1 en cas * que la millor sigui j2. * - funció percentatgeTirsLliures(intentats, encertats): * retorna el percentatge de tirs lliures en funció * dels valors passats per paràmetre. */ #define MAX_NOM 20+1 #define MAX_COGNOM 20+1 #define MAX_JUGADORES 3 typedef struct { char nom[MAX_NOM]; char cognom[MAX_COGNOM]; float rebots; float taps; float tirsLliures; /* en percentatge */ } tJugadora; /* Predeclaracions */ void llegirJugadora(tJugadora *j); void mostrarJugadora(tJugadora j); void copiarJugadora(tJugadora *desti, tJugadora origen); int compararJugadores(tJugadora j1, tJugadora j2); float percentatgeTirsLliures(int intentats, int encertats); /* Programa principal */ int main(int argc, char **argv) { tJugadora vJugadores[MAX_JUGADORES]; int i, resultat; /* Es crea la tJugadora fictícia * millorPivot que ens ajudarà a trobar * la millor opció d&#39;entre totes les * candidates */ tJugadora millorPivot; millorPivot.rebots = 0; millorPivot.taps = 0; millorPivot.tirsLliures = 0.0; /* Llegim totes les jugadores amb * l&#39;acció llegirJugadora(). Aquesta * acció rep un paràmetre de sortida * (out), el qual contindrà la * jugadora llegit per teclat. Com que * es tracta d&#39;un paràmetre de tipus * out, es realitzarà un pas per * referència (= passarem un punter) */ for (i=0; i&lt;MAX_JUGADORES; i++) { tJugadora jugadora; llegirJugadora(&amp;jugadora); vJugadores[i] = jugadora; } /* Mostrem per pantalla quina * és la millor jugadora amb perfil * pivot defensiu. La idea és anar * recorrent una a una les jugadores * del vector i comparar-les amb millorPivot: * 1. Si la jugadora del vector és millor * que millorPivot, copiarem les dades * de la jugadora cap a millorPivot. * 2. Si millorPivot és millor que la * jugadora del vector, no farem res. * En finalitzar el recorregut de totes * les jugadores del vector, tindrem que * millorPivot contindrà la jugadora * que estem buscant. * */ for (i=0; i&lt;MAX_JUGADORES; i++) { resultat = compararJugadores(millorPivot, vJugadores[i]); if (resultat != -1) { copiarJugadora(&amp;millorPivot, vJugadores[i]); } } printf(&quot;\\nMillor opció com a pivot defensiu : &quot;); mostrarJugadora(millorPivot); return 0; } /* Implementació de les accions */ void llegirJugadora(tJugadora *j) { int intentats; int encertats; printf(&quot;Introdueix les dades de la nova jugadora: \\n&quot;); printf(&quot;\\tNom: &quot;); scanf(&quot;%s&quot;, j-&gt;nom); printf(&quot;\\tCognom: &quot;); scanf(&quot;%s&quot;, j-&gt;cognom); printf(&quot;\\t&gt;&gt; Promigs per partit:\\n&quot;); printf(&quot;\\tRebots: &quot;); scanf(&quot;%f&quot;, &amp;j-&gt;rebots); printf(&quot;\\tTaps: &quot;); scanf(&quot;%f&quot;, &amp;j-&gt;taps); printf(&quot;\\tTirs lliures intentats: &quot;); scanf(&quot;%d&quot;, &amp;intentats); printf(&quot;\\tTirs lliures encertats: &quot;); scanf(&quot;%d&quot;, &amp;encertats); j-&gt;tirsLliures = percentatgeTirsLliures(intentats, encertats); } void mostrarJugadora(tJugadora j) { printf(&quot;\\n%s, %s: %.1f rebots, %.1f taps, %.1f%% tirs lliures \\n&quot;, j.cognom, j.nom, j.rebots, j.taps, j.tirsLliures); } void copiarJugadora(tJugadora *desti, tJugadora origen) { /* Recordem: * - si el paràmetre és un punter, l&#39;accessor * d&#39;atributs serà &#39;-&gt;&#39; * - si el paràmetre és un valor, l&#39;accessor * d&#39;atributs serà &#39;.&#39; */ strcpy(desti-&gt;nom, origen.nom); strcpy(desti-&gt;cognom, origen.cognom); desti-&gt;rebots = origen.rebots; desti-&gt;taps = origen.taps; desti-&gt;tirsLliures = origen.tirsLliures; } int compararJugadores(tJugadora j1, tJugadora j2) { /* Estem buscant una jugadora que * tingui un perfil de pivot defensiu, * amb el que agafarem: * 1. Aquella que tingui més rebots per partit * 2. En cas d&#39;empat de rebots, aquella que * faci més taps per partit * 3. En cas d&#39;empat, la que tingui millor * percentatge de tirs lliures */ if (j1.rebots &gt; j2.rebots) { return -1; } else { if (j1.rebots &lt; j2.rebots) { return 1; } else { /* En aquest punt tenim que * j1.rebots == j2.rebots, * amb el que anem a comparar el següent * atribut segons la prioritat definida * del perfil pivot defensiu */ if (j1.taps &gt; j2.taps) { return -1; } else { if (j1.taps &lt; j2.taps) { return 1; } else { /* Afegim la variant de valorar * el percentatge de tirs lliures */ if (j1.tirsLliures &gt;= j2.tirsLliures) { return -1; } else { return 1; } } } } } } float percentatgeTirsLliures(int intentats, int encertats) { return ((float)encertats/intentats)*100.0; } "],
["pac08.html", " 8 PAC08 8.1 Com inicialitzar una taula 8.2 Exemple: calcularNota 8.3 Exemple: calcularNota amb introducció iterativa 8.4 Exemple: recorregut vs cerca", " 8 PAC08 8.1 Com inicialitzar una taula Per inicialitzar/esborrar una taula únicament ens cal indicar que el nombre d’elements que conté és 0. La pregunta que ens podem fer és “simplement inicialitzant a 0 aquest atribut és suficient?”. La resposta és afirmativa: l’atribut que conté el nombre d’elements d’una taula sempre és l’utilitzat a l’hora de recórrer una taula, ja que ens indica quin és l’últim element de la taula. De la mateixa manera, quan inserim un element incrementarem en 1 el seu valor. Què passa quan li donem valor 0? Estem indicant que la taula té 0 elements, amb el que quan n’hi afegim un de nou ho farem a la primera posició, sobreescrivint tot el que prèviament hi pogués haver en memòria. 8.2 Exemple: calcularNota S’ha d’entendre una taula com un conjunt d’elements dels quals sabem en tot moment quants en tenim. Imaginem que volem fer un programa que calculi la nota mitjana de les PAC d’una assignatura. Podríem plantejar-ho com a un simple array d’enters, però com que ens agrada poder donar més funcionalitats en un futur al nostre programa, tindrem el següent escenari: tPac: serà el tipus de dades bàsic que tractarà el nostre programa. Aquesta tupla estarà formada d’una banda per un nom descriptiu de la pac, i d’altra banda per la seva nota numèrica amb decimals. tAssignatura: taula que contindrà elements de tipus tPac. A part d’aques array de tPac, també tindrà un comptador intern d’elements: numPacs. Sobre aquesta base realitzarem dues accions: afegir_pac(): es tracta d’una acció que inclou un element de tipus tPac dins de la taula tAssignatura. És una operació similar a l’acció d’omplir taula dels exemples de la xWiki. calcular_nota(): és una funció que revisa tots els elements tPac de la taula tAssignatura i en calcula la seva nota mitjana. Es tracta d’una operació equivalent a la dels recorreguts de taula dels exemples de la xWiki, ja que estem recorrent un a un tots els elements tPac per obtenir la seva nota. Una possible forma d’implementar-ho seria la següent: #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Definició de constants */ #define MAX_PACS 5 #define MAX_NOM 5+1 /* Definició de la tupla tPac */ typedef struct { char nom[MAX_NOM]; float nota; } tPac; /* Definició de taula tAssignatura */ typedef struct { tPac pac[MAX_PACS]; int numPacs; } tAssignatura; /* Definició funcions/accions */ /* Acció que afegeix un element de tipus tPac a la taula tAssignatura */ void afegir_pac(tAssignatura *assignatura, tPac pac); /* Funció que calcula la mitjana de totes les tPac que conté la taula * tAssignatura */ float calcular_nota(tAssignatura assignatura); /* Programa principal */ int main(int argc, char **argv) { /* Definim les variables */ tAssignatura fp; tPac pac1, pac2, pac3; float nota; /* Inicialitzem les variables */ nota = 0; strcpy(pac1.nom,&quot;PAC01&quot;); pac1.nota = 10; strcpy(pac2.nom,&quot;PAC02&quot;); pac2.nota = 8.5; strcpy(pac3.nom,&quot;PAC03&quot;); pac3.nota = 7.5; /* La inicialització de la taula es fa simplement * posant a 0 el seu comptador */ fp.numPacs=0; /* Afegim ara les pacs a l&#39;assignatura, que és una taula * d&#39;elements de tipus tPac */ afegir_pac(&amp;fp, pac1); afegir_pac(&amp;fp, pac2); afegir_pac(&amp;fp, pac3); /* i ara calculem la nota amb la funció calcular_nota */ nota = calcular_nota(fp); printf(&quot;La nota mitjana de les %d PAC és %f\\n&quot;, fp.numPacs, nota); return 0; } /* Implementació funcions/accions */ void afegir_pac(tAssignatura *assignatura, tPac pac) { /* numPacs conté el número d&#39;elements de tipus tPac * que conté la taula en cada moment */ assignatura-&gt;pac[assignatura-&gt;numPacs] = pac; /* Una vegada hem assignat un element nou tPac a la taula * incrementem el valor de numPacs */ assignatura-&gt;numPacs = assignatura-&gt;numPacs + 1; } float calcular_nota(tAssignatura assignatura) { /* La variable suma conté el sumatori de totes * les notes de les tPac que estan dins de la taula * tAssignatura */ float suma = 0; /* Es recorren tots els elements tPac de tAssignatura * per tal d&#39;obtenir la seva nota i acumular-les a la * variable suma */ for (int i = 0; i &lt; assignatura.numPacs; i++) { suma = suma + assignatura.pac[i].nota; } /* Per calcular la mitjana es divideix el sumatori de * notes pel total d&#39;elements de la taula tAssignatura */ return suma/assignatura.numPacs; } Per facilitar la lectura s’ha unit tot el programa en un únic bloc de codi (un únic arxiu). 8.3 Exemple: calcularNota amb introducció iterativa He adaptat l’exemple anterior per tal que demani els valors iterativament: #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Definició de constants */ #define MAX_PACS 10 #define MAX_NOM 10+1 /* Definició de la tupla tPac */ typedef struct { char nom[MAX_NOM]; float nota; } tPac; /* Definició de taula tAssignatura */ typedef struct { tPac pac[MAX_PACS]; int numPacs; } tAssignatura; /* Definició funcions/accions */ /* Acció que afegeix un element de tipus tPac a la taula tAssignatura */ void afegir_pac(tAssignatura *assignatura, tPac pac); /* Funció que calcula la mitjana de totes les tPac que conté la taula * tAssignatura */ float calcular_nota(tAssignatura assignatura); /* Programa principal */ int main(int argc, char **argv) { /* Definim les variables */ tAssignatura fp; float nota; int numPacs, i; /* Inicialitzem les variables */ nota = 0; numPacs = 0; i = 0; /* Inicialitzem la taula */ fp.numPacs=0; /* Introduim ara les dades de les PAC des de teclat */ printf(&quot;Número de PACs a introduir (&lt;%d): &quot;, MAX_PACS); scanf(&quot;%d&quot;, &amp;numPacs); for (i = 0; i &lt; numPacs; i++) { tPac pacAux; printf(&quot;Dades de la PAC0%d : \\n&quot;, i+1); printf(&quot;\\tNom : &quot;); scanf(&quot;%s&quot;, pacAux.nom); printf(&quot;\\tNota : &quot;); scanf(&quot;%f&quot;, &amp;pacAux.nota); /* Afegim a la taula la tPac auxiliar utilitzada * dins del bucle. En cada iteració es construirà * i s&#39;afegirà una tPac diferent */ afegir_pac(&amp;fp, pacAux); } /* Calculem la nota amb la funció calcular_nota */ nota = calcular_nota(fp); printf(&quot;La nota mitjana de les %d PAC és %f\\n&quot;, fp.numPacs, nota); return 0; } /* Implementació funcions/accions */ void afegir_pac(tAssignatura *assignatura, tPac pac) { /* numPacs conté el número d&#39;elements de tipus tPac * que conté la taula en cada moment */ assignatura-&gt;pac[assignatura-&gt;numPacs] = pac; /* Una vegada hem assignat un element nou tPac a la taula * incrementem el valor de numPacs */ assignatura-&gt;numPacs = assignatura-&gt;numPacs + 1; } float calcular_nota(tAssignatura assignatura) { /* La variable suma conté el sumatori de totes * les notes de les tPac que estan dins de la taula * tAssignatura */ float suma = 0; /* Es recorren tots els elements tPac de tAssignatura * per tal d&#39;obtenir la seva nota i acumular-les a la * variable suma */ for (int i = 0; i &lt; assignatura.numPacs; i++) { suma = suma + assignatura.pac[i].nota; } /* Per calcular la mitjana es divideix el sumatori de * notes pel total d&#39;elements de la taula tAssignatura */ return suma/assignatura.numPacs; } 8.4 Exemple: recorregut vs cerca El següent exemple es tracten els conceptes de recorregut i de cerca dels elements d’una taula. Dins del codi s’han afegit comentaris detallats per tal que cada pas quedi explicat. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; /* Ens demanen un programa que permeti registrar * jugadores de bàsquet dins d&#39;una taula. En una * mateixa taula tindrem tant les jugadores locals * com les visitants. Sobre elles hi realitzarem * un recorregut, consistent en mostrar-les totes * per pantalla, i també una cerca, on a partir * de l&#39;equip i el dorsal mostrarem per pantalla * la jugadora en cas d&#39;existir. * Ens caldrà implementar les següents accions: * - inicialitzarTaula(...): per inicialitzar la * taula de jugadores. * - afegirJugadoraATaula(...) : per afegir una * jugadora a una taula. * - mostrarJugadores(...) : per mostrar per * pantalla totes les jugadores de la taula. * - cercarJugadora(...) : per buscar dins de la * taula la jugadora que tingui un equip i * un dorsal determinat. */ #define MAX_NOM 20+1 #define MAX_COGNOM 20+1 #define MAX_JUGADORES 10 typedef enum {LOCAL, VISITANT} tEquip; typedef struct { char nom[MAX_NOM]; char cognom[MAX_COGNOM]; int dorsal; tEquip equip; } tJugadora; /* Definició del tipus taula de * jugadores; com es pot veure, tal i * com s&#39;indica a les xWiki, únicament * està formada per un bucle i un * comptador de les jugadores que conté. */ typedef struct { tJugadora jugadores[MAX_JUGADORES]; int nJugadores; } tTaulaJugadores; /* Predeclaracions */ void llegirJugadora(tJugadora *j); void mostrarJugadora(tJugadora j); void copiarJugadora(tJugadora *desti, tJugadora origen); void inicialitzarTaula(tTaulaJugadores *taula); void afegirJugadoraATaula(tTaulaJugadores *taula, tJugadora j); void mostrarJugadores(tTaulaJugadores taula); void cercarJugadora(tTaulaJugadores taula, int dorsal, tEquip equip); /* Programa principal */ int main(int argc, char **argv) { tJugadora jugadora; tTaulaJugadores taula; tEquip equip; int dorsal, i; /* Per inicialitzar una taula simplement * posem el comptador d&#39;elements a 0. Com * que la inserció de jugadores a la taula * té present aquest comptador, sobreescriurà * qualsevol altre valor que existís en * aquesta mateixa posició. */ inicialitzarTaula(&amp;taula); /* Demanem les jugadores per teclat i tot * seguit les anem afegint a la taula. */ for (i=0; i&lt;MAX_JUGADORES; i++) { llegirJugadora(&amp;jugadora); afegirJugadoraATaula(&amp;taula, jugadora); } /* Es recorren tots els elements * de la taula de jugadores per * tal d&#39;imprimir les dades per * pantalla */ mostrarJugadores(taula); printf(&quot;\\nQuina jugadora vols cercar? : &quot;); printf(&quot;\\n&gt;&gt; Equip (0=LOCAL, 1=VISITANT) : &quot;); scanf(&quot;%u&quot;, &amp;equip); printf(&quot;&gt;&gt; Dorsal : &quot;); scanf(&quot;%d&quot;, &amp;dorsal); /* Es fa una cerca entre totes les * jugadores de la taula, de forma que * mostrarà per pantalla el resultat * obtingut; si no se&#39;n troba cap, també * retorna un missatge informatiu. */ cercarJugadora(taula, dorsal, equip); return 0; } /* Implementació de les accions */ void llegirJugadora(tJugadora *j) { printf(&quot;Introdueix les dades de la nova jugadora: \\n&quot;); printf(&quot;\\tNom: &quot;); scanf(&quot;%s&quot;, j-&gt;nom); printf(&quot;\\tCognom: &quot;); scanf(&quot;%s&quot;, j-&gt;cognom); printf(&quot;\\tEquip (0=LOCAL, 1=VISITANT): &quot;); scanf(&quot;%u&quot;, &amp;j-&gt;equip); printf(&quot;\\tDorsal: &quot;); scanf(&quot;%d&quot;, &amp;j-&gt;dorsal); } void mostrarJugadora(tJugadora j) { if (j.equip == LOCAL) { printf(&quot;LOCAL : %d %s,%s\\n&quot;, j.dorsal, j.cognom, j.nom); } else { printf(&quot;VISITANT: %d %s,%s\\n&quot;, j.dorsal, j.cognom, j.nom); } } void copiarJugadora(tJugadora *desti, tJugadora origen) { strcpy(desti-&gt;nom, origen.nom); strcpy(desti-&gt;cognom, origen.cognom); desti-&gt;dorsal = origen.dorsal; desti-&gt;equip = origen.equip; } void inicialitzarTaula(tTaulaJugadores *taula) { taula-&gt;nJugadores= 0; } void afegirJugadoraATaula(tTaulaJugadores *taula, tJugadora j) { /* Es comprova primer que la taula no estigui plena! */ if(taula-&gt;nJugadores &gt;= MAX_JUGADORES) { printf(&quot;Error en afegir jugadora a la taula\\n&quot;); } else { /* S&#39;afegeix la jugadora a la taula, i s&#39;incrementa el comptador d&#39;elements de la taula */ copiarJugadora(&amp;taula-&gt;jugadores[taula-&gt;nJugadores], j); /* Important!! després d&#39;afegir una jugadora, no hem * d&#39;oblidar incrementar el comptador! */ taula-&gt;nJugadores++; } } void mostrarJugadores(tTaulaJugadores taula) { int i; i = 0; printf(&quot;\\nRecorregut: jugadores entrades a la taula ...\\n&quot;); while (i &lt; taula.nJugadores) { mostrarJugadora(taula.jugadores[i]); i = i+1; } } void cercarJugadora(tTaulaJugadores taula, int dorsal, tEquip equip) { int i; bool trobada; /* El booleà &#39;trobada&#39; s&#39;utilitzarà * per sortir del bucle que recorre totes * les jugadores de la taula: quan en trobi * una, trobada = true, i la condició d&#39;entrada * del bucle ja no es complirà, amb el que * la cerca haurà finalitzat. */ trobada = false; if (equip == LOCAL) { printf(&quot;\\nCerca: jugadora local amb dorsal núm. %d ...&quot;, dorsal); } else { printf(&quot;\\nCerca: jugadora visitant amb dorsal núm. %d ...&quot;, dorsal); } for(i=0; i&lt;taula.nJugadores &amp;&amp; !trobada; i++) { if (taula.jugadores[i].dorsal == dorsal &amp;&amp; taula.jugadores[i].equip == equip) { trobada = true; } } /* Es mostra per pantalla els resultats * obtinguts */ if (!trobada) { printf(&quot;\\n&gt;&gt; No s&#39;ha trobat cap jugadora. \\n&quot;); } else { printf(&quot;\\n&gt;&gt; Jugadora trobada : \\n&quot;); mostrarJugadora(taula.jugadores[i-1]); } } "],
["pac09.html", " 9 PAC09 9.1 Exemple", " 9 PAC09 9.1 Exemple El plantejament és el següent: imaginem que tenim una llista de cartes de tipus DIAMANTS, CORS, TREVOLS i PIQUES; el que volem aconseguir és filtrar aquesta llista per un tipus determinat de carta, DIAMANTS, i afegir totes aquestes cartes de DIAMANTS a una altra llista. He detallat al màxim el codi amb comentaris, per tal que quedi el més clar possible: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; /* Definició del model de cartes segons l&#39;enllaç: * https://ca.wikipedia.org/wiki/Joc_de_cartes#Joc_de_cartes_francès */ #define MAX_CARTES 54+1 #define MAX_DIAMANTS_CARTES 13+1 /* El terme &quot;coll&quot; equival a &quot;baraja&quot; */ typedef enum {DIAMANTS, PIQUES, TREVOLS, CORS} tColl; typedef struct { char valor; tColl coll; } tCarta; typedef struct { tCarta cartes[MAX_CARTES]; int nCartes; } tCartesList; /* Predeclaració de les accions i les funcions */ void createList(); void insert(tCartesList *llista, tCarta carta, int index); void delete(tCartesList *llista, int index); tCarta get(tCartesList llista, int index); bool end(tCartesList llista, int pos); bool emptyList(tCartesList llista); bool fullList(tCartesList llista); void printList(tCartesList llista); void getCartesByColl(tCartesList llista, tColl coll, tCartesList *llistaByColl); /* Programa principal */ int main(int argc, char **argv) { tCarta carta1, carta2, carta3, carta4, carta5; tCartesList llistaCartes, llistaCartesDiamants; /* Creem les dues llistes */ createList(&amp;llistaCartes); createList(&amp;llistaCartesDiamants); /* Definim una sèrie de cartes */ carta1.valor = &#39;3&#39;; carta1.coll = CORS; carta2.valor = &#39;A&#39;; carta2.coll = DIAMANTS; carta3.valor = &#39;J&#39;; carta3.coll = TREVOLS; carta4.valor = &#39;5&#39;; carta4.coll = DIAMANTS; carta5.valor = &#39;Q&#39;; carta5.coll = PIQUES; /* I les afegim a la llista genèrica de cartes */ insert(&amp;llistaCartes, carta1, 0); insert(&amp;llistaCartes, carta2, 1); insert(&amp;llistaCartes, carta3, 2); insert(&amp;llistaCartes, carta4, 3); insert(&amp;llistaCartes, carta5, 4); /* Mostrem el contingut de la llista de cartes * per pantalla, amb l&#39;acció printList */ printf(&quot;Contingut de la llista &#39;llistaCartes&#39; :\\n&quot;); printList(llistaCartes); /* Ara volem filtrar la llista genèrica de cartes amb * un dels colls possibles. Concretament volem separar * de la llista genèrica de cartes aquelles que siguin * del coll DIAMANTS; ho fem mitjançant la crida a * l&#39;acció getCartesByColl. Per veure el seu funcionament, * reviseu el comentari fet en la implementació d&#39;aquesta * acció */ getCartesByColl(llistaCartes, DIAMANTS, &amp;llistaCartesDiamants); /* I mostrem ara el contingut de la llista que conté * únicament les cartes del coll DIAMANTS */ printf(&quot;Contingut de la llista &#39;llistaCartesDiamants&#39; :\\n&quot;); printList(llistaCartesDiamants); return 0; } /* Implementació dels mètodes de la llista: he fet un copy/paste * de la codificació C de l&#39;exemple 19_12 de la xWiki, canviant * el genèric &quot;elem&quot; per &quot;tCarta&quot;, i el genèric &quot;list&quot; per &quot;tCartesList&quot;, * ja que aquests seran els elements amb els que treballarem * en aquest exemple */ void createList(tCartesList *llista) { llista-&gt;nCartes = 0; } void insert(tCartesList *llista, tCarta carta, int index) { int i = 0; if (llista-&gt;nCartes == MAX_CARTES) { printf(&quot;\\n Full list \\n&quot;); } else { for (i=llista-&gt;nCartes-1; i&gt;=index; i--) { llista-&gt;cartes[i+1] = llista-&gt;cartes[i]; } llista-&gt;nCartes++; llista-&gt;cartes[index]=carta; } } void delete(tCartesList *llista, int index) { int i; if (llista-&gt;nCartes == 0) { printf(&quot;\\n Empty list\\n&quot;); } else { for (i=index; i&lt;llista-&gt;nCartes-1; i++) { llista-&gt;cartes[i] = llista-&gt;cartes[i+1]; } llista-&gt;nCartes--; } } tCarta get(tCartesList llista, int index) { tCarta carta; if (llista.nCartes == 0) { printf(&quot;\\n Empty list \\n&quot;); } else { carta=llista.cartes[index]; } return carta; } bool end(tCartesList llista, int pos) { return (pos &gt;= llista.nCartes); } bool emptyList(tCartesList llista) { return (llista.nCartes == 0); } bool fullList(tCartesList llista) { return (llista.nCartes == MAX_CARTES); } /* A continuació s&#39;implementaran dues noves accions que * no surten ja a l&#39;exemple 19_12. La primera acció, * printList, imprimeix per pantalla una llista. La segona * acció, getCartesByColl, permet fer un filtratge de * cartes sobre una llista. */ void printList(tCartesList llista) { int i; tCarta cartaAux; for(i = 0; i &lt; llista.nCartes; i++) { cartaAux = get(llista, i); if (cartaAux.coll == DIAMANTS) { printf(&quot; [%c] de DIAMANTS\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == PIQUES) { printf(&quot; [%c] de PIQUES\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == TREVOLS) { printf(&quot; [%c] de TREVOLS\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == CORS) { printf(&quot; [%c] de CORS\\n&quot;, cartaAux.valor); } } } /* La següent acció, getCartesByColl, rep tres paràmetres: * tCartesList llista (in) : * llista sobre la qual aplicarem el filtre * * tColl tipus (in) : * correspon al tipus de coll que utilitzarem per fer * el filtratge; per exemple, si com a coll indiquem * DIAMANTS significa que el filtratge el farem * sobre les cartes de tipus DIAMANTS * * tCartesList llistaByColl (out) : * llista de sortida en la qual s&#39;hi inclouran aquelles * cartes de la llista d&#39;entrada que són del coll tipus */ void getCartesByColl(tCartesList llista, tColl tipus, tCartesList *llistaByColl) { int i, j; tCarta carta; createList(llistaByColl); i = 0; j = 0; /* Amb un bucle i la funció end, controlem que no * hem arribat al final de la llista */ while ( end(llista, i) == false ) { /* Obtenim la carta de la posició i */ carta = get(llista, i); /* Si la carta és del coll indicat per tipus, * s&#39;afegeix a la llista de sortida */ if (carta.coll == tipus) { insert(llistaByColl, carta, j); j = j + 1; } i = i + 1; } } "],
["pac10.html", " 10 PAC10", " 10 PAC10 "],
["pr1.html", " 11 PR1 11.1 Mode menu vs mode test 11.2 Exemple: tupla dins de tupla 11.3 Desplaçament d’elements en un vector", " 11 PR1 11.1 Mode menu vs mode test El workspace de la PR1 té habilitats dos modes de funcionament/execució. Per activar un mode o un altre fem el següent, amb el workspace de la PR1 obert: CodeLite –&gt; Build –&gt; Configuration manager… Aquí es mostra un desplegable amb dues opcions: Menu: és el mode estàndard de funcionament del programa, el qual mostra el menú per pantalla amb les accions que permet realitzar. Test: s’executen una sèrie de tests per validar que les accions que hem codificat al nostre programa funcionin com s’espera que ho facin. Tant si s’escull l’opció Menu com l’opció Test, després hem de fer l’habitual CodeLite –&gt; Build –&gt; Build and Run Project per executar el programa en el mode que hem escollit. 11.2 Exemple: tupla dins de tupla De vegades pot costar veure com treballar amb atributs d’una tupla que a la seva vegada està dins d’una altra tupla, si s’hi accedeix per valor, per referència (punter), etc. Per aquest motiu, s’adjunta el següent exemple inventat, en el qual s’hi han afegit comentaris per tal que es vegi clarament com treballar amb atributs d’una tupla continguda dins d’una altra tupla: #include &lt;stdio.h&gt; #include &lt;string.h&gt; /* Un parking d&#39;un centre comercial ens ha * encarregat una app que faciliti els seus * clients a localitzar on ha aparcat el seu * vehicle. * * El parking ja disposa de tres tipus de * càmeres, independents entre elles: * * - d&#39;entrada: càmera posicionada a l&#39;entrada * del pàrking que, a més de llegir la matrícula, * permet saber el tipus de vehicle. * * - d&#39;accés: càmeres que ens permeten * saber si un vehicle ha pujat o ha baixat * una planta. * * - de planta: càmeres que ens permeten saber * la fila i eĺ número de plaça on s&#39;ha * aparcat un vehicle. * * L&#39;identificador de vehicle és la seva * matrícula. * * A partir de la informació obtinguda pels * tres conjunts de càmeres, caldrà indicar * a l&#39;usuari on ha aparcat el seu vehicle. */ #define MAX_MATRICULA 7+1 typedef enum {COTXE, MOTO, FURGONETA} tTipus; /* El lloc on aparca un vehicle ve donat * per tres valors: la planta, la fila i el * número de la plaça. */ typedef struct { int planta; char fila; int numero; } tAparcament; /* El tipus tVehicle conté la seva matrícula * (identificador únic), el tipus de vehicle * detectat en la primera càmera (COTXE, MOTO, * FURGONETA), i el lloc on ha aparcat (tAparcament) */ typedef struct { char matricula[MAX_MATRICULA]; tTipus tipus; tAparcament aparcament; } tVehicle; /* Predeclaració d&#39;accions */ void inicialitzar(tVehicle *vehicle, tTipus tipus, char *matricula); void pujarPlanta(tVehicle *vehicle); void baixarPlanta(tVehicle *vehicle); void aparcar(tVehicle *vehicle, char fila, int numero); void obtenirPosicio(tVehicle); /* Programa principal */ int main(int argc, char **argv){ tVehicle vehicle; /* Es llegeix la matrícula del vehicle amb la * càmera d&#39;entrada del pàrking i s&#39;assigna * a l&#39;element de tipus tVehicle del nostre * pàrking */ printf(&quot;\\n&gt;&gt; Entrada al pàrking \\n&quot;); inicialitzar(&amp;vehicle, COTXE, &quot;7472GZZ&quot;); printf(&quot;\\n&gt;&gt; Baixar una planta\\n&quot;); baixarPlanta(&amp;vehicle); printf(&quot;\\n&gt;&gt; Baixar una planta\\n&quot;); baixarPlanta(&amp;vehicle); printf(&quot;\\n&gt;&gt; Pujar una planta\\n&quot;); pujarPlanta(&amp;vehicle); printf(&quot;\\n&gt;&gt; Baixar una planta\\n&quot;); baixarPlanta(&amp;vehicle); printf(&quot;\\n&gt;&gt; Baixar una planta\\n&quot;); baixarPlanta(&amp;vehicle); printf(&quot;\\n&gt;&gt; Aparcar\\n&quot;); aparcar(&amp;vehicle, &#39;C&#39;, 23); printf(&quot;\\nAnem a comprar regals de reis ...&quot;); printf(&quot;\\n... passem més de 3 hores ...&quot;); printf(&quot;\\n... i ens oblidem d&#39;on hem aparcat el vehicle !!\\n&quot;); printf(&quot;\\nSolució: consultem la posició del nostre vehicle &quot;); printf(&quot;\\na l&#39;app del pàrquing : \\n&quot;); obtenirPosicio(vehicle); return 0; } /* Com que la posició ve donada pels atributs planta, fila i * numero de tAparcament, és molt important que inicialitzem * els valors (sobretot per la planta). La planta inicial del * pàrking és la 0, i la resta de plantes són soterrades. */ void inicialitzar(tVehicle *vehicle, tTipus tipus, char *matricula) { strcpy(vehicle-&gt;matricula, matricula); vehicle-&gt;tipus = tipus; /* L&#39;accés a l&#39;atribut aparcament (tupla) el fem amb -&gt; * ja que es tracta d&#39;un punter, i accedim * als atributs de la tupla aparcament amb . */ vehicle-&gt;aparcament.planta = 0; vehicle-&gt;aparcament.fila = &#39;-&#39;; vehicle-&gt;aparcament.numero = 0; } /* Quan pugem una planta, incrementem en 1 l&#39;atribut * planta de la tupla tAparcament que conté la tupla tVehicle */ void pujarPlanta(tVehicle *vehicle) { vehicle-&gt;aparcament.planta = vehicle-&gt;aparcament.planta + 1; } /* Quan baixem una planta, decrementem en 1 l&#39;atribut * planta de la tupla tAparcament que conté la tupla tVehicle */ void baixarPlanta(tVehicle *vehicle) { vehicle-&gt;aparcament.planta = vehicle-&gt;aparcament.planta - 1; } /* Quan aparquem el vehicle, donem valor als atributs * fila i numero de la tupla tAparcament que conté la * tupla tVehicle */ void aparcar(tVehicle *vehicle, char fila, int numero) { vehicle-&gt;aparcament.fila = fila; vehicle-&gt;aparcament.numero = numero; } /* Mostrem per pantalla la posició del tVehicle */ void obtenirPosicio(tVehicle vehicle) { if (vehicle.tipus == COTXE) { printf(&quot;\\nCotxe %s : &quot;, vehicle.matricula); } else { if (vehicle.tipus == MOTO) { printf(&quot;\\nMoto %s : &quot;, vehicle.matricula); } else { printf(&quot;\\nFurgoneta %s : &quot;, vehicle.matricula); } } /* En aquest cas l&#39;accés a l&#39;atribut aparcament (tupla) * es fa amb . ja que s&#39;ha passat per valor (no és un punter) * i accedim als atributs de la tupla aparcament amb . */ printf(&quot;planta %d, &quot;, vehicle.aparcament.planta); printf(&quot;fila %c, &quot;, vehicle.aparcament.fila); printf(&quot;número %d \\n&quot;, vehicle.aparcament.numero); } El resultat de l’execució d’aquest programa és: &gt;&gt; Entrada al pàrking &gt;&gt; Baixar una planta &gt;&gt; Baixar una planta &gt;&gt; Pujar una planta &gt;&gt; Baixar una planta &gt;&gt; Baixar una planta &gt;&gt; Aparcar Anem a comprar regals de reis ... ... passem més de 3 hores ... ... i ens oblidem d&#39;on hem aparcat el vehicle !! Solució: consultem la posició del nostre vehicle a l&#39;app del parking : Cotxe 7472GZZ : planta -3, fila C, número 23 11.3 Desplaçament d’elements en un vector Els desplaçaments en un vector es poden produir quan s’afegeix o s’elimina un element d’un vector. 11.3.1 Afegir un element Volem afegir un element dins del vector de la taula en una posició que no és l’última. Per exemple, si volem que els elements que afegim a un vector vagin a la posició inicial, caldrà abans desplaçar la resta d’elements una posició a la dreta: Contingut inicial del vector: [element2] [element5] [element1] [element7] Abans d’afegir el nou element6, caldrà desplaçar tots els elements una posició cap a la dreta, per tal de fer un buit a l’inici: [........] [element2] [element5] [element1] [element7] Ara ja es pot afegir l’element6 a la primera posició del vector: [element6] [element2] [element5] [element1] [element7] Important: com a darrer pas, incrementar en 1 l’atribut que conté la mida de la taula. 11.3.2 Esborrar un element Quan volem eliminar un element d’un vector també es pot produir un desplaçament d’elements. Per exemple: Contingut inicial del vector: [element2] [element5] [element1] [element7] Per eliminar l’element5 simplement desplacem la resta d’elements que van a continuació una posició cap a l’esquerra: [element2] [element1] [element7] Important: com a darrer pas, decrementar en 1 l’atribut que conté la mida de la taula. 11.3.3 Exemple: diesSetmana A continuació s’adjunta un exemple inventat per consolidar aquesta explicació: la idea és que pugueu comparar la inserció d’elements a una taula com hem fet habitualment fins ara (afegits al final de tot), amb una altra acció que permet afegir de forma ordenada els elements a la taula. En aquesta segona inserció caldrà anar realitzant desplaçaments cap a la dreta dels elements del vector de la taula per tal que vagin quedant ordenats. #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; /* Definició de constants */ #define MAX_DIES 7 #define MAX_NOM 9+1 /* Definició de la tupla tDia */ typedef struct { char nom[MAX_NOM]; int id; } tDia; /* Definició de la taula tSetmana */ typedef struct { tDia dies[MAX_DIES]; int numDies; } tSetmana; /* Predeclaració de les accions */ /* Acció que inicialitza la taula tSetmana, * tot posant l&#39;atribut numDies a 0 */ void inicialitzar(tSetmana *setmana); /* Acció que afegeix un element de tipus tDia * a la taula tSetmana */ void afegirDia(tSetmana *setmana, tDia dia); /* Acció que afegeix un element de tipus tDia * a la taula tSetmana de forma ordenada */ void afegirDiaOrdenat(tSetmana *setmana, tDia dia); /* Acció que copia el contingut d&#39;un tDia origen (src) * a un tDia destí (dst) */ void copiarDia(tDia *dst, tDia src); /* Acció que mostra per pantalla el contingut * de la taula tSetmana */ void mostrar(tSetmana setmana); /* Programa principal */ int main(int argc, char **argv) { /* Definim les variables */ tSetmana setmana, setmanaOrdenada; tDia dl, dm, dc, dj, dv, ds, dg; /* Inicialitzem les variables de tipus tDia */ strcpy(dl.nom, &quot;dilluns&quot;); dl.id = 1; strcpy(dm.nom, &quot;dimarts&quot;); dm.id = 2; strcpy(dc.nom, &quot;dimecres&quot;); dc.id = 3; strcpy(dj.nom, &quot;dijous&quot;); dj.id = 4; strcpy(dv.nom, &quot;divendres&quot;); dv.id = 5; strcpy(ds.nom, &quot;dissabte&quot;); ds.id = 6; strcpy(dg.nom, &quot;diumenge&quot;); dg.id = 7; /* Inicialitzem les variables de tipus * tSetmana */ inicialitzar(&amp;setmana); inicialitzar(&amp;setmanaOrdenada); /* Afegim sense ordre les variables * tDia dins de les taules setmana * i setmanaOrdenada. La diferència * entre elles serà el mètode utilitzat * per inserir els tDia: mentre que * la inserció per setmana serà * l&#39;habitual d&#39;afegir com a darrer * element de la taula, per la * setmanaOrdenada utilitzarem l&#39;acció * afegirDiaOrdenat() */ afegirDia(&amp;setmana, dj); afegirDia(&amp;setmana, dl); afegirDia(&amp;setmana, dc); afegirDia(&amp;setmana, dg); afegirDia(&amp;setmana, ds); afegirDia(&amp;setmana, dm); afegirDia(&amp;setmana, dv); afegirDiaOrdenat(&amp;setmanaOrdenada, dj); afegirDiaOrdenat(&amp;setmanaOrdenada, dl); afegirDiaOrdenat(&amp;setmanaOrdenada, dc); afegirDiaOrdenat(&amp;setmanaOrdenada, dg); afegirDiaOrdenat(&amp;setmanaOrdenada, ds); afegirDiaOrdenat(&amp;setmanaOrdenada, dm); afegirDiaOrdenat(&amp;setmanaOrdenada, dv); printf(&quot;\\nSetmana sense ordenar : \\n&quot;); mostrar(setmana); printf(&quot;\\nSetmana ordenada : \\n&quot;); mostrar(setmanaOrdenada); return 0; } /* Implementació de les accions */ void inicialitzar(tSetmana *setmana) { setmana-&gt;numDies = 0; } void afegirDia(tSetmana *setmana, tDia dia) { /* numDies conté el número d&#39;elements * de tipus tDia que conté la taula * tSetmana en cada moment */ copiarDia(&amp;setmana-&gt;dies[setmana-&gt;numDies], dia); /* Una vegada assignat un element nou * tDia a la taula, incrementem el valor * de numDies */ setmana-&gt;numDies = setmana-&gt;numDies + 1; } /* Acció que afegeix un element de tipus tDia * a la taula tSetmana de forma ordenada */ void afegirDiaOrdenat(tSetmana *setmana, tDia dia) { int i, j; bool isAfegit; isAfegit = false; i = 0; /* Per fer l&#39;ordenació s&#39;utilitzarà el camp * id de tDia */ for (i = 0; i &lt; setmana-&gt;numDies &amp;&amp; !isAfegit; i++) { /* Si l&#39;id del tDia de la tSetmana &gt; id del * paràmetre dia, a partir d&#39;aquest punt * caldrà desplaçar les tuples tDia cap * a la dreta. L&#39;objectiu és aconseguir un * lloc lliure, on s&#39;afegirà el tDia dia * passat com a paràmetre a l&#39;acció */ if (setmana-&gt;dies[i].id &gt; dia.id) { /* Desplaçament dels tDia cap a la dreta, a * partir de la posició on caldrà afegir * el paràmetre dia passat per valor */ for (j = setmana-&gt;numDies; j &gt; i; j--) { copiarDia(&amp;setmana-&gt;dies[j], setmana-&gt;dies[j-1]); } /* S&#39;afegeix el paràmetre dia a la * posició que li correspon, una vegada * desplaçats la resta de tuples tDia * cap a dreta */ copiarDia(&amp;setmana-&gt;dies[j], dia); setmana-&gt;numDies = setmana-&gt;numDies + 1; isAfegit = true; } } /* Si en aquest punt encara no s&#39;ha * afegit el tDia, significa que ha d&#39;anar * al final de tot de la taula tSetmana */ if (!isAfegit) { copiarDia(&amp;setmana-&gt;dies[i], dia); setmana-&gt;numDies = setmana-&gt;numDies + 1; } } void copiarDia(tDia *dst, tDia src) { dst-&gt;id = src.id; strcpy(dst-&gt;nom, src.nom); } void mostrar(tSetmana setmana) { int i; for (i = 0; i &lt; setmana.numDies; i++) { printf(&quot;%s\\n&quot;, setmana.dies[i].nom); } } L’execució del programa genera la següent sortida: Setmana sense ordenar : dijous dilluns dimecres diumenge dissabte dimarts divendres Setmana ordenada : dilluns dimarts dimecres dijous divendres dissabte diumenge "],
["pr2.html", " 12 PR2 12.1 Exemple", " 12 PR2 12.1 Exemple Adjunto un exemple inventat on, donada una pila de cartes inicial, el que volem és codificar l’acció separarDiamants que ens permeti separar de la pila totes aquelles que són DIAMANTS, afegint-les a una nova pila de cartes DIAMANTS. Exemple: si inicialment tenim la pila1: [Q] de PIQUES [5] de DIAMANTS [J] de TREVOLS [A] de DIAMANTS [3] de CORS Volem que d’una banda la pila1 contingui totes les cartes que no són DIAMANTS: [3] de CORS [J] de TREVOLS [Q] de PIQUES I d’altra banda una nova pila2 amb totes les cartes DIAMANTS: [A] de DIAMANTS [5] de DIAMANTS He afegit comentaris al codi explicant tot el plantejament: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; /* Definició del model de cartes segons l&#39;enllaç: https://ca.wikipedia.org/wiki/Joc_de_cartes#Joc_de_cartes_francès */ #define MAX_CARTES 54+1 /* El terme &quot;coll&quot;&quot; equival a &quot;baraja&quot; */ typedef enum {DIAMANTS, PIQUES, TREVOLS, CORS} tColl; typedef struct { char valor; tColl coll; } tCarta; typedef struct { tCarta A[MAX_CARTES]; int nelem; } tStack; /* Predeclaració de les accions i les funcions */ void createStack(tStack *s); void push(tStack *s, tCarta e); void pop(tStack *s); tCarta top(tStack s); bool emptyStack(tStack s); bool fullStack(tStack s); void printStack(tStack s); void separarDiamants(tStack *pilaCartes, tStack *pilaDiamants); /* Programa principal */ int main(int argc, char **argv) { tCarta carta1, carta2, carta3, carta4, carta5; tStack pilaCartes, pilaCartesDiamants; /* Creem dues piles (reviseu el comentari inicial del bloc * d&#39;implementació de les accions/funcions de la pila). */ createStack(&amp;pilaCartes); createStack(&amp;pilaCartesDiamants); /* Definim una sèrie de cartes. */ carta1.valor = &#39;3&#39;; carta1.coll = CORS; carta2.valor = &#39;A&#39;; carta2.coll = DIAMANTS; carta3.valor = &#39;J&#39;; carta3.coll = TREVOLS; carta4.valor = &#39;5&#39;; carta4.coll = DIAMANTS; carta5.valor = &#39;Q&#39;; carta5.coll = PIQUES; /* I les afegim totes a pilaCartes */ push(&amp;pilaCartes, carta1); push(&amp;pilaCartes, carta2); push(&amp;pilaCartes, carta3); push(&amp;pilaCartes, carta4); push(&amp;pilaCartes, carta5); /* Mostrem el contingut de pilaCartes per * pantalla, amb l&#39;acció addicional printStack. */ printf(&quot;\\nContingut de la pila &#39;pilaCartes&#39; :\\n&quot;); printStack(pilaCartes); /* Ara volem separar de pilaCartes totes * aquelles cartes que són DIAMANTS, les quals * formaran part d&#39;una nova pila de cartes. */ printf(&quot;\\nSeparem les cartes en dues piles!!\\n&quot;); /* Explicació detallada dins de la implementació * de l&#39;acció. */ separarDiamants(&amp;pilaCartes, &amp;pilaCartesDiamants); printf(&quot;\\nContingut de la pila &#39;pilaCartes&#39; sense DIAMANTS :\\n&quot;); printStack(pilaCartes); printf(&quot;\\nContingut de la pila &#39;pilaCartesDiamants&#39; :\\n&quot;); printStack(pilaCartesDiamants); return 0; } /* Implementació de les accions/funcions de la pila: he fet un copy/paste * de la codificació C de l&#39;exemple 19_04 de la xWiki, canviant * el genèric &quot;elem&quot; per &quot;tCarta&quot;. * * !!! Atenció !!!: hi poden haver diferències amb funcions/accions * que us demanen a la PR2. De cara a la PR2 heu de codificar aquests * mètodes segons les indicacions de l&#39;enunciat. */ void createStack(tStack *s) { s-&gt;nelem=0; } void push(tStack *s, tCarta e) { if (s-&gt;nelem == MAX_CARTES) { printf(&quot;\\n Full stack \\n&quot;); } else { s-&gt;A[s-&gt;nelem]=e; /* first position in C is 0 */ s-&gt;nelem++; } } void pop(tStack *s) { if (s-&gt;nelem == 0) { printf(&quot;\\n Empty stack\\n&quot;); } else { s-&gt;nelem--; } } tCarta top(tStack s) { tCarta e; if (s.nelem == 0) { printf(&quot;\\n Empty stack \\n&quot;); } else { e = s.A[s.nelem-1]; } return e; } bool emptyStack(tStack s) { return (s.nelem == 0); } bool fullStack(tStack s) { return (s.nelem == MAX_CARTES); } /* Acció addicional que mostra per pantalla tots * els elements d&#39;una pila. */ void printStack(tStack s) { tCarta cartaAux; while (s.nelem &gt; 0) { cartaAux = s.A[s.nelem-1]; if (cartaAux.coll == DIAMANTS) { printf(&quot; [%c] de DIAMANTS\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == PIQUES) { printf(&quot; [%c] de PIQUES\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == TREVOLS) { printf(&quot; [%c] de TREVOLS\\n&quot;, cartaAux.valor); } else if (cartaAux.coll == CORS) { printf(&quot; [%c] de CORS\\n&quot;, cartaAux.valor); } s.nelem--; } } /* Acció que rep dos paràmetres: * - pilaCartes (inout) * - pilaDiamants (out) * Aquesta acció separa de pilaCartes (inout) aquelles * cartes amb coll DIAMANTS, i les afegeix a * pilaDiamants (out). Així una vegada executada l&#39;acció, tindrem: * - pilaCartes: contindrà totes les cartes que no són DIAMANTS. * - pilaDiamants: contindrà tots els DIAMANTS. */ void separarDiamants(tStack *pilaCartes, tStack *pilaDiamants) { tCarta cartaAux; tStack pilaNoDiamants; /* Totes les cartes inicialment estan a pilaCartes. * Es tracta d&#39;anar afegint els DIAMANTS a la pilaDiamants, * i els que no són DIAMANTS a la pila temporal pilaNoDiamants. * Posteriorment assignarem pilaNoDiamants a pilaCartes (inout). */ /* Inicialitzem la pila auxiliar. */ createStack(&amp;pilaNoDiamants); /* Hem de tractar tots els elements de la pila. */ while (!emptyStack(*pilaCartes)) { cartaAux = top(*pilaCartes); if (cartaAux.coll == DIAMANTS) { push(pilaDiamants, cartaAux); } else { push(&amp;pilaNoDiamants, cartaAux); } pop(pilaCartes); } /* Reassignació de la pila auxiliar pilaNoDiamants * a pilaCartes, que al cap i a la fi és el paràmetre * de tipus inout de l&#39;acció. */ *pilaCartes = pilaNoDiamants; } "],
["vmware-i-codelite.html", " 13 VMWare i CodeLite 13.1 Per què una màquina virtual? 13.2 VirtualBox i requeriments de virtualització 13.3 Com instal·lar les Guest Additions 13.4 Primers passos amb CodeLite 13.5 Com activar un projecte 13.6 Canviar idioma del teclat 13.7 Programa per defecte al crear un projecte", " 13 VMWare i CodeLite 13.1 Per què una màquina virtual? La màquina virtual s’utilitza per tenir un entorn homogeni de programació, tant per part dels estudiants com per part dels consultors, de forma que qualsevol enunciat/solució publicat a les aules de teoria funcioni a tots els estudiants, i que tots els programes que realitzeu es comportin igual als entorns que s’utilitzaran per corregir-los. Fa uns semestres ens vam trobar amb uns pocs casos en els quals un programa que funcionava correctament al PC d’un estudiant, fallava a l’hora de ser corregit. I també alguns enunciats que en determinats sistemes operatius / versions de compiladors C, tampoc funcionaven correctament. Per aquest motiu es va decidir utilitzar una màquina virtual. Nosaltres no tenim forma de controlar que realment utilitzeu la FP20181 o bé un CodeLite instal·lat directament al vostre PC, però si no és així es pot donar alguna situació poc desitjable com les que he comentat. 13.2 VirtualBox i requeriments de virtualització Per poder utilitzar VirtualBox és necessari que disposi d’accés a l’opció de virtualització. Si no és així, es poden obtenir errors del tipus: VT-X está deshabilitado en el BIOS para todos los CPUs. L’error es pot produir per vàries raons: La BIOS del PC té deshabilitada l’opció. Per solucionar-ho, cal entrar dins de la BIOS del PC i trobar l’opció d’activació de la virtualització (varia segons el fabricant): pot ser VT-x, Virtualization Technology, VT-x/AMD-V, Intel Virtual Technology, Tecnología de virtualización (VTx/VTd), etc. Tenim actiu un antivirus el qual té activada una virtualització pròpia que entra en conflicte amb la requerida per VirtualBox. En aquest cas, únicament cal desactivar l’opció de virtualització de l’antivirus. 13.3 Com instal·lar les Guest Additions Les Guest Additions són una sèrie de drivers que milloren la interacció entre host i màquina virtual. Per instal·lar-les únicament cal fer: Engegar la màquina virtual FP20181 Anar a la barra de menú superior -&gt; VirtualBox -&gt; Devices -&gt; Insert Guest Additions CD Image… -&gt; instal·larà una unitat de CD amb les Guest Additions. Obrir un terminal des de Lubuntu -&gt; System Tools -&gt; LXTerminal Dins del terminal LXTerminal executar el següent (la versió que s’estigui instal·lant pot ser més nova que la 6.0.12): cd /media/uoc/VBox_GAs_6.0.12/ sudo sh ./VBoxLinuxAdditions.run Reiniciar la FP20181 per activar les Guest Additions. 13.4 Primers passos amb CodeLite A les xWiki trobareu el mòdul Introducció a l’entorn de programació CodeLite, en el qual es detallen els passos a realitzar per preparar l’entorn. A continuació resumeixo una sèrie d’aspectes que es comenten a la xWiki i que són importants recordar: Un workspace de CodeLite és una agrupació de projectes. Únicament es pot tenir un workspace obert dins de CodeLite. Per crear un workspace: CodeLite -&gt; Workspace -&gt; New Workspace… -&gt; Workspace type: C++ -&gt; Workspace name: el que correspongui; Workspace Path: /home/uoc/Documents/codelite/workspaces/ (o qualsevol altre) -&gt; fi Com que no es pot tenir més d’un workspace obert, no en podreu crear cap de nou si prèviament no tanqueu el workspace actiu. Si dins del menú de CodeLite veieu la opció New Workspace en gris i que no es pot seleccionar, significa que ja teniu un workspace obert. Per tancar-lo: CodeLite -&gt; Workspace -&gt; Close Workspace. Per afegir un projecte a un workspace: CodeLite -&gt; File -&gt; New -&gt; New Project -&gt; de tipus Console: Simple executable (gcc) -&gt; Project name: el que correspongui -&gt; Compiler: GCC; Debugger: GNU gdb debugger -&gt; fi El projecte que acabem de crear conté un programa hello world de mostra, que si executem mostra el missatge “hello world” per pantalla. Aquest programa en C el podem editar i afegir/treure tot allò que volem. És aquí dins on hem de codificar els nostres programes en C (no els algorismes!). Si tenim més d’un projecte dins d’un workspace, la forma que tenim per indicar quin d’ells és el que està actiu és fent doble clic sobre el nom del projecte. Veureu que el nom queda remarcat en negre i cursiva: a partir d’aquest moment, aquest serà el projecte que compilarem i executarem des de les opcions del menú de CodeLite. Tot i que estiguem visualitzant per pantalla el codi d’un altre projecte, la compilació i execució sempre es farà del projecte actiu. Per mostrar la barra d’eines (icones) a la part superior: CodeLite -&gt; View -&gt; Show toolbar. La icona del play de color verd cap a la dreta de la toolbar és per debuggar, no per compilar. Per compilar i executar podem fer: CodeLite -&gt; Build -&gt; Build and run project. També es pot compilar amb la icona de la toolbar de la fletxa blanca avall amb fons verd, i executar amb la icona de les rodes dentades grises. El resultat de l’execució del programa es mostrarà en una pantalla nova tipus terminal. És important anar tancant aquestes finestres una vegada ja hem comprovat el resultat de l’execució. 13.5 Com activar un projecte Dins de CodeLite, a la part esquerra es mostren tots els projects que s’han creat al workspace. Si ens fixem en el nom de tots ells, veurem que un està remarcat en negreta; per exemple podem tenir: PAC01 PAC02 PAC03 PAC04 Això significa que quan anem a CodeLite –&gt; Build –&gt; Build and Run Project, s’executarà l’acció sobre el project PAC02, tot i que per pantalla s’estigui mostrant el codi d’un altre project. Si es fa doble clic amb el ratolí sobre el nom del project PAC04, ara veurem: PAC01 PAC02 PAC03 PAC04 A partir d’aquest moment, el Build and Run Project s’aplicarà sobre PAC04. 13.6 Canviar idioma del teclat Dins de l’escriptori de Lubuntu, clica amb el botó dret del ratolí sobre la barra grisa superior -&gt; Add/Remove Panel Items -&gt; pestanya Panel Applets -&gt; botó Add -&gt; selecciona el plugin Keyboard Layout Handler -&gt; Add -&gt; Close. En aquests moments a la part superior dreta se’t mostrarà l’idioma definit per defecte pel teclat -&gt; marca sobre la bandera amb el botó dret -&gt; “Keyboard Layout Handler” settings -&gt; desmarca l’opció Keep system layout -&gt; i aquí ja pots afegir l’idioma que vulguis des del botó Add; pots prioritzar un idioma o l’altre posant-lo en primera posició a la llista. Una vegada hagis guardat la configuració desitjada, ja t’haurà canviat la disposició del teclat al nou idioma. Si has deixat definits varis idiomes a la llista, cada vegada que cliquis sobre la bandera de la part superior dreta, et farà un canvi a l’altre idioma de la llista. 13.7 Programa per defecte al crear un projecte Cada vegada que es crea un nou projecte a CodeLite, per defecte sempre conté el codi del programa hello world: #include &lt;stdio.h&gt; int main(int argc, char **argv) { printf(&quot;hello world\\n&quot;); return 0; } Per tant, quan volem crear el nostre propi programa, només cal esborrar el programa que crea per defecte i començar a codificar el teu programa nou. Si malgrat tot no es vol que es mostri aquest codi cada vegada, podem modificar el codi per defecte associat als nous projectes: Editar l’arxiu /usr/share/codelite/templates/projects/executable/main.cpp, que és el que es carrega per defecte en crear cada nou projecte. Crear un nou template de CodeLite i utilitzar-lo en el moment de crear un nou projecte. La creació d’un nou templates es fa a partir d’un projecte que tinguem -&gt; botó dret sobre el nom del projecte -&gt; Save as template.... "],
["altres.html", " 14 Altres 14.1 Bilbliografia", " 14 Altres 14.1 Bilbliografia Recursos gratuïts: C Notes for Professionals book: https://books.goalkicker.com/CBook/ C Programming: https://en.wikibooks.org/wiki/C_Programming C Programming Boot Camp: https://www.gribblelab.org/CBootCamp/ The C Book: https://publications.gbdirect.co.uk//c_book/ Programming in C: http://ee.hawaii.edu/~tep/EE160/Book/PDF/Book.html The ANSI C Programming Language: https://www.dipmat.univpm.it/~demeio/public/the_c_programming_language_2.pdf "]
]
